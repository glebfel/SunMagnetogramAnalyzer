<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CSharpFITS</name>
    </assembly>
    <members>
        <member name="T:nom.tam.fits.AsciiTable">
            <summary>An ASCII table.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.#ctor(nom.tam.fits.Header)">
            <summary>Create an ASCII table given a header</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.#ctor">
            <summary>Create an empty ASCII table</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.GetColumn(System.Int32)">
            <summary>Get a column of data</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.GetRow(System.Int32)">
            <summary>Get a row.  If the data has not yet been read just read this row.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.GetElement(System.Int32,System.Int32)">
            <summary>Get a single element as a one-d array.
            We return String's as arrays for consistency though
            they could be returned as a scalar.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.SetColumn(System.Int32,System.Object)">
            <summary>Replace a column with new data.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.SetRow(System.Int32,System.Array)">
            <summary>Modify a row in the table</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.SetElement(System.Int32,System.Int32,System.Object)">
            <summary>Modify an element in the table</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.AddColumn(System.Object)">
            <summary>Add a row to the table. Users should be cautious
            of calling this routine directly rather than the corresponding
            routine in AsciiTableHDU since this routine knows nothing
            of the FITS header modifications required.
            </summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.AddRow(System.Array)">
            <summary>Add a row to the FITS table.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.DeleteRows(System.Int32,System.Int32)">
            <summary>Delete rows from a FITS table.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.DeleteColumns(System.Int32,System.Int32)">
            <summary>Delete columns from the table.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.UpdateAfterDelete(System.Int32,nom.tam.fits.Header)">
            .99.1 changes
            <summary>
            This is called after we delete columns.  The HDU
            doesn't know how to update the TBCOL entries.
            </summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.Read(nom.tam.util.ArrayDataIO)">
            <summary>Read in an ASCII table.  Reading is deferred if
            we are reading from a random access device</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.GetBuffer(System.Int32,System.Int64)">
            <summary>Read some data into the buffer.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.ExtractElement(System.Int32,System.Int32,System.Array,System.Int32,System.Int32,System.String)">
            <summary>Move an element from the buffer into a data array.</summary>
            <param name="offset"> The offset within buffer at which the element starts.</param>
            <param name="length"> The number of bytes in the buffer for the element.</param>
            <param name="array">  An array of objects, each of which is a simple array.</param>
            <param name="col">    Which element of array is to be modified?</param>
            <param name="row">    Which index into that element is to be modified?</param>
            <param name="nullFld">What string signifies a null element?</param>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.SingleRow(System.Int32)">
            <summary>Extract a single row from a table.  This returns
            an array of Objects each of which is an array of length 1.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.SingleElement(System.Int32,System.Int32)">
            <summary>Extract a single element from a table.  This returns
            an array of length 1.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.ParseSingleRow(System.Int32)">
            <summary>Read a single row from the table.  This returns a set of arrays of dimension 1.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.ParseSingleElement(System.Int32,System.Int32)">
            <summary>Read a single element from the table.  This returns an array of dimension 1.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.Write(nom.tam.util.ArrayDataIO)">
            <summary>Write the data to an output stream.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.SetNull(System.Int32,System.Int32,System.Boolean)">
            <summary>Mark (or unmark) an element as null.  Note that if this FITS file is latter
            written out, a TNULL keyword needs to be defined in the corresponding
            header.  This routine does not add an element for String columns.
            </summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.IsNull(System.Int32,System.Int32)">
            <summary>See if an element is null.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.AddColumn(System.Object,System.Int32)">
            <summary>This version of addColumn allows the user to override
            the default length associated with each column type.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.SetNullString(System.Int32,System.String)">
            <summary>Set the null string for a columns.
            This is not a public method since we
            want users to call the method in AsciiTableHDU
            and update the header also.
            </summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTable.FillHeader(nom.tam.fits.Header)">
            <summary>Fill in a header with information that points to this data.</summary>
        </member>
        <member name="P:nom.tam.fits.AsciiTable.DataArray">
            <summary>Get the ASCII table information.
            This will actually do the read if it had previously been deferred</summary>
        </member>
        <member name="P:nom.tam.fits.AsciiTable.TrueSize">
            <summary>Return the size of the data section</summary>
        </member>
        <member name="P:nom.tam.fits.AsciiTable.NRows">
            <summary>Get the number of rows in the table</summary>
        </member>
        <member name="P:nom.tam.fits.AsciiTable.NCols">
            <summary>Get the number of columns in the table</summary>
        </member>
        <member name="P:nom.tam.fits.AsciiTable.RowLen">
            <summary>Get the number of bytes in a row</summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTable.nRows">
            <summary>The number of rows in the table</summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTable.nFields">
            <summary>The number of fields in the table</summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTable.rowLen">
            <summary>The number of bytes in a row</summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTable.nulls">
            <summary>The null string for the field</summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTable.types">
            <summary>The type of data in the field</summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTable.offsets">
            <summary>The offset from the beginning of the row at which the field starts</summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTable.lengths">
            <summary>The number of bytes in the field</summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTable.buffer">
            <summary>The byte buffer used to read/write the ASCII table</summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTable.isNull_Renamed_Field">
            <summary>Markers indicating fields that are null</summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTable.data">
            <summary>An array of arrays giving the data in the table in binary numbers</summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTable.bp">
            <summary>The parser used to convert from buffer to data.</summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTable.currInput">
            <summary>The actual stream used to input data</summary>
        </member>
        <member name="T:nom.tam.fits.AsciiTableHDU">
            <summary> FITS ASCII table header/data unit
            </summary>
        </member>
        <member name="P:nom.tam.fits.AsciiTableHDU.HasHeader">
            <summary> Check that this HDU has a valid header.</summary>
            <returns> <CODE>true</CODE> if this HDU has a valid header.</returns>
        </member>
        <member name="P:nom.tam.fits.AsciiTableHDU.Data">
            <summary>
            Returns data object of the AsciiTableHDU
            </summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTableHDU.data">
            <summary>Just a copy of myData with the correct type</summary>
        </member>
        <member name="F:nom.tam.fits.AsciiTableHDU.keyStems">
            Suggested in .97 version
            <summary>
            The standard column stems for an ASCII table.
            Note that TBCOL is not included here -- it needs to 
            be handled specially since it does not simply shift.
            </summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.#ctor(nom.tam.fits.Header,nom.tam.fits.Data)">
            <summary>
            Create an ascii table header/data unit
            </summary>
            <param name="h">The template specifying the ascii table.</param>
            <param name="d"> The FITS data structure containing the table data.</param>
             <exception cref="T:nom.tam.fits.FitsException"> FitsException if there was a problem with the header.</exception>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.IsHeader(nom.tam.fits.Header)">
            <summary> Check that this is a valid ascii table header.</summary>
            <param name="header">to validate.</param>
            <returns> <CODE>true</CODE> if this is an ascii table header.</returns>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.IsData(System.Object)">
            <summary>Check if this data is usable as an ASCII table.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.ManufactureData(nom.tam.fits.Header)">
            <summary> Create a Data object to correspond to the header description.</summary>
            <returns> An unfilled Data object which can be used to read in the data for this HDU.</returns>
            <exception cref="T:nom.tam.fits.FitsException"> FitsException if the Data object could not be created from this HDU's Header</exception>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.ManufactureData">
            <summary>Create an empty data structure corresponding to the input header.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.ManufactureHeader(nom.tam.fits.Data)">
            <summary>Create a header to match the input data.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.Encapsulate(System.Object)">
            <summary>
            Create a ASCII table data structure from 
            an array of objects representing the columns.
            </summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.ReadData(nom.tam.util.ArrayDataIO)">
            <summary> Skip the ASCII table and throw an exception.</summary>
            <param name="stream">the stream from which the data is read.</param>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.SetNull(System.Int32,System.Int32,System.Boolean)">
            <summary>Mark an entry as null.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.IsNull(System.Int32,System.Int32)">
            <summary>See if an element is null</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.SetNullString(System.Int32,System.String)">
            <summary>Set the null string for a column</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.AddColumn(System.Object)">
            <summary>Add a column</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.Info">
            <summary> Print a little information about the data set.</summary>
        </member>
        <member name="M:nom.tam.fits.AsciiTableHDU.GetData">
            <summary>Return the FITS data structure associated with this HDU.</summary>
        </member>
        <member name="P:nom.tam.fits.AsciiTableHDU.ColumnKeyStems">
            Suggested in .97 version
            <summary>Return the keyword column stems for an ASCII table.</summary>
        </member>
        <member name="T:nom.tam.fits.BadHeaderException">
            <summary>This exception indicates that an error
            was detected while parsing a FITS header record.
            </summary>
        </member>
        <member name="M:nom.tam.fits.BadHeaderException.#ctor">
            <summary>
            Constructor without arguments
            </summary>
        </member>
        <member name="M:nom.tam.fits.BadHeaderException.#ctor(System.String)">
            <summary>
            Constructor with String argument for exception message
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:nom.tam.fits.BasicHDU">
            <summary>This abstract class is the parent of all HDU types.
            It provides basic functionality for an HDU.
            </summary>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.CanBePrimary">
            <summary>Indicate whether HDU can be primary HDU.
            This method must be overriden in HDU types which can
            appear at the beginning of a FITS file.</summary>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Header">
            <summary>Get the associated header</summary>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.FileOffset">
            <summary>Get the starting offset of the HDU</summary>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Data">
            <summary>Get the associated Data object</summary>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Kernel">
            <summary>Get the non-FITS data object</summary>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Size">
            <summary>Get the total size in bytes of the HDU.</summary>
            <returns>The size in bytes.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:nom.tam.fits.BasicHDU.BitPix" -->
        <!-- Badly formed XML comment ignored for member "P:nom.tam.fits.BasicHDU.Axes" -->
        <member name="P:nom.tam.fits.BasicHDU.ParameterCount">
            <summary>
            Returns the value oF PCOUNT from HDU
            </summary>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.GroupCount">
            <summary>
            Returns the value oF GCOUNT from HDU
            </summary>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.BScale">
             <summary>
             Returns the value oF BSCALE from HDU
            The value field shall contain a floating point number.The default value for this keyword os 1.0
             </summary>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.BZero">
            <summary>
            Returns the value oF BZero from HDU
            This keyword shall be used, along with the BSCALE keyword
            The default value for this keyword is 0.0.
            </summary>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.BUnit">
            <summary>
            The value shall contain a character String, describing the physical
            units in which the quantities in the array, after application of BSCALE and BZERO,are expressed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:nom.tam.fits.BasicHDU.BlankValue" -->
        <member name="P:nom.tam.fits.BasicHDU.CreationDate">
            <summary> Get the FITS file creation date as a <CODE>Date</CODE> object.</summary>
            <returns>	either <CODE>null</CODE> or a Date object</returns>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.ObservationDate">
            <summary> Get the FITS file observation date as a <CODE>Date</CODE> object.</summary>
            <returns>	either <CODE>null</CODE> or a Date object</returns>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Origin">
            <summary> Get the name of the organization which created this FITS file.</summary>
            <returns>	either <CODE>null</CODE> or a String object</returns>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Telescope">
            <summary> Get the name of the telescope which was used to acquire the data in this FITS file.</summary>
            <returns>	either <CODE>null</CODE> or a String object</returns>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Instrument">
            <summary> Get the name of the instrument which was used to acquire the data in this FITS file.</summary>
            <returns>	either <CODE>null</CODE> or a String object</returns>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Observer">
            <summary>Get the name of the person who acquired the data in this FITS file.</summary>
            <returns>	either <CODE>null</CODE> or a String object</returns>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Object">
            <summary> Get the name of the observed object in this FITS file.</summary>
            <returns>	either <CODE>null</CODE> or a String object</returns>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Equinox">
            <summary> Get the equinox in years for the celestial coordinate system in which
            positions given in either the header or data are expressed.</summary>
            <returns>	either <CODE>null</CODE> or a String object</returns>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Epoch">
            <summary> Get the equinox in years for the celestial coordinate system in which
            positions given in either the header or data are expressed.</summary>
            <returns>	either <CODE>null</CODE> or a String object</returns>
            <deprecated>	Replaced by getEquinox</deprecated>
            <seealso cref="!:">#getEquinox()</seealso>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Author">
            <summary> Return the name of the person who compiled the information in
            the data associated with this header.</summary>
            <returns>	either <CODE>null</CODE> or a String object</returns>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Reference">
            <summary> Return the citation of a reference where the data associated with
            this header are published.</summary>
            <returns>	either <CODE>null</CODE> or a String object</returns>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.MaximumValue">
            <summary> Return the minimum valid value in the array.</summary>
            <returns>	minimum value.</returns>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.MinimumValue">
            <summary> Return the minimum valid value in the array.</summary>
            <returns>	minimum value.</returns>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.PrimaryHDU">
            <summary>Indicate that an HDU is the first element of a FITS file.</summary>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.DummyHDU">
            <summary>
            Returns DummyHDu instance
            </summary>
        </member>
        <member name="P:nom.tam.fits.BasicHDU.Rewriteable">
            <summary>Is the HDU rewriteable</summary>
        </member>
        <member name="F:nom.tam.fits.BasicHDU.BITPIX_BYTE">
            <summary>
            Constant for BitPix byte value
            </summary>
        </member>
        <member name="F:nom.tam.fits.BasicHDU.BITPIX_SHORT">
            <summary>
            Constant for BitPix short value
            </summary>
        </member>
        <member name="F:nom.tam.fits.BasicHDU.BITPIX_INT">
            <summary>
            Constant for BitPix integer value
            </summary>
        </member>
        <member name="F:nom.tam.fits.BasicHDU.BITPIX_LONG">
            <summary>
            Constant for BitPix long value
            </summary>
        </member>
        <member name="F:nom.tam.fits.BasicHDU.BITPIX_FLOAT">
            <summary>
            Constant for BitPix float value
            </summary>
        </member>
        <member name="F:nom.tam.fits.BasicHDU.BITPIX_DOUBLE">
            <summary>
            Constant for BitPix double value
            </summary>
        </member>
        <member name="F:nom.tam.fits.BasicHDU.myHeader">
            <summary>The associated header.</summary>
        </member>
        <member name="F:nom.tam.fits.BasicHDU.myData">
            <summary>The associated data unit.</summary>
        </member>
        <member name="F:nom.tam.fits.BasicHDU.isPrimary">
            <summary>Is this the first HDU in a FITS file?</summary>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.ManufactureData">
            <summary>Create a Data object to correspond to the header description.</summary>
            <returns> An unfilled Data object which can be used to read in the data for this HDU.</returns>
            <exception cref="T:nom.tam.fits.FitsException"> FitsException if the Data object could not be created
            from this HDU's Header</exception>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.SkipData(nom.tam.util.ArrayDataIO,nom.tam.fits.Header)">
            <summary>Skip the Data object immediately after the given Header object on
            the given stream object.</summary>
            <param name="stream">the stream which contains the data.</param>
            <param name="hdr">template indicating length of Data section</param>
            <exception cref="T:System.IO.IOException"> IOException if the Data object could not be skipped.</exception>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.SkipData(nom.tam.util.ArrayDataIO)">
            <summary>Skip the Data object for this HDU.</summary>
            <param name="stream">the stream which contains the data.</param>
            <exception cref="T:System.IO.IOException"> IOException if the Data object could not be skipped.</exception>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.ReadData(nom.tam.util.ArrayDataIO)">
            <summary>Read in the Data object for this HDU.</summary>
            <param name="stream">the stream from which the data is read.</param>
            <exception cref="T:nom.tam.fits.FitsException"> FitsException if the Data object could not be created from this HDU's Header</exception>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.IsHeader(nom.tam.fits.Header)">
            <summary>Check that this is a valid header for the HDU.</summary>
            <param name="header">to validate.</param>
            <returns> <CODE>true</CODE> if this is a valid header.</returns>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.Info">
            <summary>Print out some information about this HDU.</summary>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.CheckField(System.String)">
            <summary>Check if a field is present and if so print it out.</summary>
            <param name="name">The header keyword.</param>
            <returns>Was it found in the header?</returns>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.Read(nom.tam.util.ArrayDataIO)">
            <summary>Read out the HDU from the data stream.  This
            will overwrite any existing header and data components.
            </summary>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.Write(nom.tam.util.ArrayDataIO)">
            <summary>Write out the HDU.</summary>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.Rewrite">
            <summary>Rewrite the HDU.</summary>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.GetTrimmedString(System.String)">
            <summary>
            Get the String value associated with <CODE>keyword</CODE>
            </summary>
            <param name="keyword"></param>
            <returns>either <CODE>null</CODE> or a String with leading/trailing blanks stripped.</returns>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.AddValue(System.String,System.Boolean,System.String)">
            <summary>Add boolean information to the header</summary>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.AddValue(System.String,System.Int32,System.String)">
            <summary>Add int information to the header</summary>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.AddValue(System.String,System.Double,System.String)">
            <summary>Add double information to the header</summary>
        </member>
        <member name="M:nom.tam.fits.BasicHDU.AddValue(System.String,System.String,System.String)">
            <summary>Add String information to the header</summary>
        </member>
        <member name="T:nom.tam.fits.BinaryTable">
            <summary>
            This class defines the methods for accessing FITS binary table data.
            </summary>
        </member>
        <member name="P:nom.tam.fits.BinaryTable.NRows">
            <summary>Get the number of rows in the table</summary>
        </member>
        <member name="P:nom.tam.fits.BinaryTable.NCols">
            <summary>Get the number of columns in the table.</summary>
        </member>
        <member name="P:nom.tam.fits.BinaryTable.TrueSize">
            <summary>Get the size of the data in the HDU sans padding.</summary>
        </member>
        <member name="P:nom.tam.fits.BinaryTable.DataArray">
            <summary>
            Reads the data 
            </summary>
        </member>
        <member name="P:nom.tam.fits.BinaryTable.Dimens">
            <summary>
            Returns the dimensions 
            </summary>
        </member>
        <member name="P:nom.tam.fits.BinaryTable.Bases">
            <summary>
            Returns the Type[] of bases
            </summary>
        </member>
        <member name="P:nom.tam.fits.BinaryTable.FlatColumns">
            <summary>
            Returns the flattened column object array
            </summary>
        </member>
        <member name="P:nom.tam.fits.BinaryTable.Sizes">
            <summary>
            Hets the size array
            </summary>
        </member>
        <member name="P:nom.tam.fits.BinaryTable.HeapSize">
            <summary> What is the size of the heap -- including 
            the offset from the end of the table data.</summary>
        </member>
        <member name="P:nom.tam.fits.BinaryTable.HeapOffset">
            <summary> What is the offset to the heap.</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.heap">
            <summary>This is the area in which variable length column data lives.</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.heapOffset">
            <summary>The number of bytes between the end of the data and the heap</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.sizes">
            <summary>The sizes of each column (in number of entries per row)</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.dimens">
            <summary>The dimensions of each column.
            If a column is a scalar then entry for that 
            index is an array of length 0.</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.WarnedOnVariableConversion">
            Suggested in .99 version
            <summary>Flag indicating that we've given Variable length conversion warning.
            We only want to do that once per HDU.</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.flags">
            <summary>Info about column</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.nRow">
            <summary>The number of rows in the table.</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.nCol">
            <summary>The number of columns in the table.</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.rowLen">
            <summary>The length in bytes of each row.</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.bases">
            <summary>The base classes for the arrays in the table.</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.modelRow">
            <summary>An example of the structure of a row</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.columns">
            <summary>A pointer to the data in the columns.  This
            variable is only used to assist in the
            construction of BinaryTable's that are defined
            to point to an array of columns.  It is
            not generally filled.  The ColumnTable is used
            to store the actual data of the BinaryTable.
            </summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.table">
            <summary>Where the data is actually stored.</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTable.currInput">
            <summary>The stream used to input the image</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.#ctor">
            <summary>Create a null binary table data segment.</summary>
            <exception cref="T:nom.tam.util.TableException"> TableException</exception>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.#ctor(nom.tam.fits.Header)">
            <summary>Create a binary table from given header information.</summary>
            <param name="myHeader">header describing what the binary table should look like.</param>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.#ctor(System.Object[][])">
            <summary>Create a binary table from existing data in row order.</summary>
            <param name="data">The data used to initialize the binary table.</param>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.#ctor(System.Object[])">
            <summary>Create a binary table from existing data in column order.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.#ctor(nom.tam.util.ColumnTable)">
            <summary>Create a binary table from an existing ColumnTable.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.ProcessCol(nom.tam.fits.Header,System.Int32)">
            <summary>Process one column from a FITS Header.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.GetTformType(System.String)">
            <summary>Get the type in the TFORM field</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.GetTformVarType(System.String)">
            <summary>Get the type in a varying length column TFORM</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.GetTformLength(System.String)">
            <summary>Get the explicit or implied length of the TFORM field</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.InitialNumber(System.String)">
            <summary>Get an unsigned number at the beginning of a string.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.GetTDims(System.String)">
            <summary>Parse the TDIMS value.
            If the TDIMS value cannot be deciphered a one-d
            array with the size given in arrsiz is returned.
            </summary>
            <param name="tdims">The value of the TDIMSn card.</param>
            <returns>An int array of the desired dimensions.
            Note that the order of the tdims is the inverse
            of the order in the TDIMS key.</returns>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.FillHeader(nom.tam.fits.Header)">
            <summary> Update a FITS header to reflect the current state of the data.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.PointToColumn(System.Int32,nom.tam.fits.Header)">
            <summary> Update the header to reflect information about a given column.
            This routine tries to ensure that the Header is organized by column.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.FillForColumn(nom.tam.fits.Header,System.Int32,nom.tam.util.Cursor)">
            <summary> Update the header to reflect the details of a given column.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.CreateTable">
            <summary>Create a column table given the number of
            rows and a model row.  This is used when
            we defer instantiation of the ColumnTable until
            the user requests data from the table.
            </summary>
            <exception cref="!:"> TableException Thrown when the new data
            is not of the same type as the data it replaces.</exception>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.ConvertToColumns(System.Object[][])">
            <summary>Convert a two-d table to a table of columns.  Handle
            String specially.  Every other element of data should be
            a primitive array of some dimensionality.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.GetRow(System.Int32)">
            <summary>Get a given row</summary>
            <param name="row">The index of the row to be returned.</param>
            <returns>A row of data.</returns>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.GetMemoryRow(System.Int32)">
            <summary>Get a row from memory.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.GetFileRow(System.Int32)">
            <summary>Get a row from the file.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.SetRow(System.Int32,System.Array)">
            <summary>Replace a row in the table.</summary>
            <param name="row"> The index of the row to be replaced.</param>
            <param name="data">The new values for the row.</param>
            <exception cref="!:"> FitsException Thrown if the new row cannot
            match the existing data.</exception>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.SetColumn(System.Int32,System.Object)">
            <summary>Replace a column in the table.</summary>
            <param name="col">The index of the column to be replaced.</param>
            <param name="xcol">The new data for the column</param>
            <exception cref="!:"> FitsException Thrown if the data does not match
            the current column description.</exception>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.SetFlattenedColumn(System.Int32,System.Object)">
            <summary>Set a column with the data aleady flattened.</summary>
            <param name="col"> The index of the column to be replaced.</param>
            <param name="data">The new data array.  This should be a one-d
            primitive array.</param>
            <exception cref="!:"> FitsException Thrown if the type of length of
            the replacement data differs from the original.</exception>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.GetColumn(System.Int32)">
            <summary>Get a given column</summary>
            <param name="col">The index of the column.</param>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.GetFlattenedColumn(System.Int32)">
            <summary>Get a column in flattened format.
            For large tables getting a column in standard format can be
            inefficient because a separate object is needed for
            each row.  Leaving the data in flattened format means
            that only a single object is created.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.GetElement(System.Int32,System.Int32)">
            <summary>Get a particular element from the table.</summary>
            <param name="i">The row of the element.</param>
            <param name="j">The column of the element.</param>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.getRawElement(System.Int32,System.Int32)">
            .99.5 change: Added method.
            <summary>Get a particular element from the table but
            do no processing of this element (e.g.,
            dimension conversion or extraction of
            variable length array elements/)</summary>
            <param name="i"> The row of the element.</param>
            <param name="j"> The column of the element.</param>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.AddRow(System.Array)">
            <summary> Given the way the
            table is structured this will normally not be very efficient.</summary>
            <param name="o">An array of elements to be added.  Each element of o
            should be an array of primitives or a String.</param>
            <exception cref="T:nom.tam.util.TableException"> TableException Thrown.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:nom.tam.fits.BinaryTable.DeleteRows(System.Int32,System.Int32)" -->
        <member name="M:nom.tam.fits.BinaryTable.AddColumn(System.Object)">
            <summary>Add a column to the end of a table.</summary>
            <param name="o">An array of identically structured objects with the
            same number of elements as other columns in the table.</param>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.IsVarying(System.Object)">
            <summary>Is this a variable length column?
            It is if it's a two-d primitive array and
            the second dimension is not constant.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.AddFlattenedColumn(System.Object,System.Int32[])">
            <summary>Add a column where the data is already flattened.</summary>
            <param name="o">The new column data.  This should be a one-dimensional primitive array.</param>
            <param name="dims">The dimensions of one row of the column.</param>
            <exception cref="T:nom.tam.util.TableException"> TableException Thrown when the new data
            is not of the same type as the data it replaces.</exception>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.ValidRow(System.Int32)">
            <summary>Check to see if this is a valid row.</summary>
            <param name="i">The index (first=0) of the row to check.</param>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.ValidColumn(System.Int32)">
            <summary>Check if the column number is valid.</summary>
            <param name="j">The index (first=0) of the column to check.</param>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.SetElement(System.Int32,System.Int32,System.Object)">
            <summary>Replace a single element within the table.</summary>
            <param name="i">The row of the data.</param>
            <param name="j">The column of the data.</param>
            <param name="o">The replacement data.</param>
            <exception cref="!:"> TableException Thrown when the new data
            is not of the same type as the data it replaces.</exception>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.Read(nom.tam.util.ArrayDataIO)">
            <summary>Read the data -- or defer reading on random access</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.ReadTrueData(nom.tam.util.ArrayDataIO)">
            <summary>Read table, heap and padding</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.Write(nom.tam.util.ArrayDataIO)">
            <summary>Write the table, heap and padding</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.ArrayToColumn(System.Int32,System.Object)">
            <summary>Convert the external representation to the
            BinaryTable representation.  Transformation include
            boolean -> T/F, Strings -> byte arrays,
            variable length arrays -> pointers (after writing data
            to heap).
            </summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.ColumnToArray(System.Int32,System.Object,System.Int32)">
            <summary>Convert data from binary table representation to external Java representation.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.ExtendArrays(System.Int32)">
            <summary>Make sure the arrays which describe the columns are
            long enough, and if not extend them.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.IsVarCol(System.Int32)">
            <summary> Does this column have variable length arrays?</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.IsLongVary(System.Int32)">
            <summary> Does this column have variable length arrays?</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.IsString(System.Int32)">
            <summary>Is this column a string column.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.IsComplex(System.Int32)">
            <summary> Is this column complex?</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.IsBoolean(System.Int32)">
            <summary> Is this column a boolean column.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.IsBit(System.Int32)">
            <summary> Is this column a bit column.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.DeleteColumns(System.Int32,System.Int32)">
            <summary> Delete a set of columns.  Note that this
            does not fix the header, so users should normally
            call the routine in TableHDU.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTable.UpdateAfterDelete(System.Int32,nom.tam.fits.Header)">
            <summary> Update the header after a deletion.</summary>
        </member>
        <member name="T:nom.tam.fits.BinaryTableHDU">
            <summary>FITS binary table header/data unit</summary>
        </member>
        <member name="F:nom.tam.fits.BinaryTableHDU.keyStems">
            <summary> The standard column keywords for a binary table.</summary>
        </member>
        <member name="P:nom.tam.fits.BinaryTableHDU.HasHeader">
            <summary>Check that this HDU has a valid header.</summary>
            <returns> <CODE>true</CODE> if this HDU has a valid header.</returns>
        </member>
        <member name="P:nom.tam.fits.BinaryTableHDU.ColumnKeyStems">
            <summary>
            Returns the standars column keywords
            </summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTableHDU.#ctor(nom.tam.fits.Header,nom.tam.fits.Data)">
            <summary>
            Consructor initislizing header,data
            </summary>
            <param name="hdr"></param>
            <param name="datum"></param>
        </member>
        <member name="M:nom.tam.fits.BinaryTableHDU.ManufactureData(nom.tam.fits.Header)">
            <summary>Create data from a binary table header.</summary>
            <param name="header">the template specifying the binary table.</param>
            <exception cref="!:"> FitsException if there was a problem with the header.</exception>
        </member>
        <member name="M:nom.tam.fits.BinaryTableHDU.ManufactureHeader(nom.tam.fits.Data)">
            <summary>Build a binary table HDU from the supplied data.</summary>
            <param name="data">the array used to build the binary table.</param>
            <exception cref="T:nom.tam.fits.FitsException"> If there was a problem with the data.</exception>
        </member>
        <member name="M:nom.tam.fits.BinaryTableHDU.Encapsulate(System.Object)">
            <summary>Encapsulate data in a BinaryTable data type</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTableHDU.IsHeader(nom.tam.fits.Header)">
            <summary>Check that this is a valid binary table header.</summary>
            <param name="header">to validate.</param>
            <returns> <CODE>true</CODE> if this is a binary table header.</returns>
        </member>
        <member name="M:nom.tam.fits.BinaryTableHDU.IsData(System.Object)">
            <summary>Check if this data object is consistent with a binary table.  There
            are three options:  a column table object, an Object[][], or an Object[].
            This routine doesn't check that the dimensions of arrays are properly
            consistent.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTableHDU.AddColumn(System.Object)">
            <summary>Add a column without any associated header information.</summary>
            <param name="data">The column data to be added.  Data should be an Object[] where
            type of all of the constituents is identical.  The length
            of data should match the other columns.  <b> Note:</b> It is
            valid for data to be a 2 or higher dimensionality primitive
            array.  In this case the column index is the first 
            index of the array.  E.g., if called with int[30][20][10], the
            number of rows in the table should be 30 and this column
            will have elements which are 2-d integer arrays with TDIM = (10,20).
            </param>
            <exception cref="!:"> FitsException the column could not be added.</exception>
        </member>
        <member name="M:nom.tam.fits.BinaryTableHDU.Write(nom.tam.util.ArrayDataIO)">
            <summary>Need to tell header about the Heap before writing.</summary>
        </member>
        <member name="M:nom.tam.fits.BinaryTableHDU.Info">
            <summary>Print out some information about this HDU.</summary>
        </member>
        <member name="T:nom.tam.fits.Data">
            <summary>This class provides methods to access the data segment of an HDU.</summary>
        </member>
        <member name="P:nom.tam.fits.Data.Rewriteable">
            <summary>
            Returns whether input stream is rewritable
            </summary>
        </member>
        <member name="P:nom.tam.fits.Data.FileOffset">
            <summary>Get the file offset</summary>
        </member>
        <member name="P:nom.tam.fits.Data.Size">
            <summary>Get the size of the data element in bytes</summary>
        </member>
        <member name="P:nom.tam.fits.Data.DataArray">
            <summary>Return the data array object.</summary>
        </member>
        <member name="P:nom.tam.fits.Data.Kernel">
            <summary>Return the non-FITS data object</summary>
        </member>
        <member name="F:nom.tam.fits.Data.fileOffset">
            <summary>The starting location of the data when last read</summary>
        </member>
        <member name="F:nom.tam.fits.Data.dataSize">
            <summary>The size of the data when last read</summary>
        </member>
        <member name="F:nom.tam.fits.Data.input">
            <summary>The inputstream used.</summary>
        </member>
        <member name="M:nom.tam.fits.Data.Write(nom.tam.util.ArrayDataIO)">
            <summary>Write the data -- including any buffering needed</summary>
            <param name="o"> The output stream on which to write the data.</param>
        </member>
        <member name="M:nom.tam.fits.Data.Read(nom.tam.util.ArrayDataIO)">
            <summary>Read a data array into the current object and if needed position
            to the beginning of the next FITS block.</summary>
            <param name="i">The input data stream</param>
        </member>
        <member name="M:nom.tam.fits.Data.FillHeader(nom.tam.fits.Header)">
            <summary>Modify a header to point to this data</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:nom.tam.fits.Fits" -->
        <member name="F:nom.tam.fits.Fits.DEFAULT_TEMP_DIR">
            <summary>
            default directory path to store files created temporarily during execution of library
            </summary>
        </member>
        <member name="F:nom.tam.fits.Fits.UrlProtocols">
            <summary> What might URLs begin with?</summary>
        </member>
        <member name="F:nom.tam.fits.Fits._tempDir">
            <summary>
            directory path to store temporary fits files
            </summary>
        </member>
        <member name="F:nom.tam.fits.Fits.atEOF">
            <summary>Has the input stream reached the EOF?</summary>
        </member>
        <member name="F:nom.tam.fits.Fits.dataStr">
            <summary>The input stream associated with this Fits object.</summary>
        </member>
        <member name="F:nom.tam.fits.Fits.hduList">
            <summary>A vector of HDUs that have been added to this Fits object.</summary>
        </member>
        <member name="M:nom.tam.fits.Fits.#ctor">
            <summary>Create an empty Fits object which is not associated with an input stream.</summary>
        </member>
        <member name="M:nom.tam.fits.Fits.#ctor(System.IO.Stream)">
            <summary>Create a Fits object associated with
            the given uncompressed data stream.
            </summary>
            <param name="str">The data stream.</param>
        </member>
        <member name="M:nom.tam.fits.Fits.#ctor(System.IO.Stream,System.Boolean)">
            <summary>Create a Fits object associated with a possibly
            compressed data stream.
            </summary>
            <param name="str">The data stream.</param>
            <param name="compressed">Is the stream compressed?</param>
        </member>
        <member name="M:nom.tam.fits.Fits.#ctor(System.IO.FileInfo)">
            <summary>Associate FITS object with an uncompressed File</summary>
            <param name="myFile">The File object.</param>
        </member>
        <member name="M:nom.tam.fits.Fits.#ctor(System.IO.FileInfo,System.Boolean)">
            <summary>Associate the Fits object with a File</summary>
            <param name="myFile">The File object.</param>
            <param name="compressed">Is the data compressed?</param>
        </member>
        <member name="M:nom.tam.fits.Fits.#ctor(System.String)">
            <summary>Associate the FITS object with a file or URL.
            *
            The string is assumed to be a URL if it begins one of the
            protocol strings.
            If the string ends in .gz it is assumed that
            the data is in a compressed format.
            All string comparisons are case insensitive.
            *
            </summary>
            <param name="filename">The name of the file or URL to be processed.</param>
            <exception cref="!:"> FitsException Thrown if unable to find or open
            a file or URL from the string given.</exception>
        </member>
        <member name="M:nom.tam.fits.Fits.#ctor(System.String,System.IO.FileAccess)">
            <summary>
            Asscoiates a fits object with a file specified by the Fileaccess parameter
            </summary>
            <param name="filename"></param>
            <param name="access"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:nom.tam.fits.Fits.#ctor(System.String,System.Boolean,System.IO.FileAccess)" -->
        <member name="M:nom.tam.fits.Fits.#ctor(System.Uri)">
            <summary>Associate the FITS object with a given uncompressed URL</summary>
            <param name="myURL">The URL to be associated with the FITS file.</param>
            <exception cref="T:nom.tam.fits.FitsException">Thrown if unable to use the specified URL.</exception>
        </member>
        <member name="M:nom.tam.fits.Fits.#ctor(System.Uri,System.Boolean)">
            <summary>Associate the FITS object with a given URL</summary>
            <param name="myURL">The URL to be associated with the FITS file.</param>
            <param name="compressed">Is the data compressed?</param>
            <exception cref="T:nom.tam.fits.FitsException">Thrown if unable to find or open
            a file or URL from the string given.</exception>
        </member>
        <member name="P:nom.tam.fits.Fits.TempDirectory">
            <summary>
            Gets the temporary directory path
            </summary>
        </member>
        <member name="P:nom.tam.fits.Fits.NumberOfHDUs">
            <summary>Get the current number of HDUs in the Fits object.</summary>
            <returns>The number of HDU's in the object.</returns>
        </member>
        <member name="P:nom.tam.fits.Fits.Stream">
            <summary>Get the data stream used for the Fits Data.</summary>
            <returns> The associated data stream.  Users may wish to
            call this function after opening a Fits object when
            they wish detailed control for writing some part of the FITS file.
            </returns>
            <summary>Set the data stream to be used for future input.</summary>
            <param name="stream">The data stream to be used.</param>
        </member>
        <member name="M:nom.tam.fits.Fits.Write(System.Data.IDataReader,System.String)">
            <summary>
            writes the header to fits file
            </summary>
            <param name="reader"></param>
            <param name="filename"></param>
        </member>
        <member name="M:nom.tam.fits.Fits.Write(System.Data.IDataReader,System.String,nom.tam.fits.StreamedBinaryTableHDU.StringWriteMode,System.Int32,System.Boolean,System.Char)">
            <summary>
            writes the header to fits file
            </summary>
            <param name="reader"></param>
            <param name="filename"></param>
            <param name="writeMode"></param>
            <param name="stringTruncationLength"></param>
            <param name="padStringsLeft"></param>
            <param name="stringPadChar"></param>
        </member>
        <member name="M:nom.tam.fits.Fits.InitBlock">
            <summary>
            Initializes the HDU array list
            </summary>
        </member>
        <member name="M:nom.tam.fits.Fits.Version">
            <summary>Indicate the version of these classes</summary>
        </member>
        <member name="M:nom.tam.fits.Fits.StreamInit(System.IO.Stream,System.Boolean,System.Boolean)">
            <summary>Do the stream initialization.</summary>
            <param name="str">The input stream.</param>
            <param name="compressed">Is this data compressed?  If so,
            then the GZIPInputStream class will be
            used to inflate it.</param>
        </member>
        <member name="M:nom.tam.fits.Fits.RandomInit(System.IO.FileInfo,System.IO.FileAccess)">
            <summary>Initialize using buffered random access</summary>
        </member>
        <member name="M:nom.tam.fits.Fits.FileInit(System.IO.FileInfo,System.Boolean)">
            <summary>Get a stream from the file and then use the stream initialization.</summary>
            <param name="myFile">The File to be associated.</param>
            <param name="compressed">Is the data compressed?</param>
        </member>
        <member name="M:nom.tam.fits.Fits.Read">
            <summary>Return all HDUs for the Fits object.   If the
            FITS file is associated with an external stream make
            sure that we have exhausted the stream.</summary>
            <returns> an array of all HDUs in the Fits object.  Returns
            null if there are no HDUs associated with this object.
            </returns>
        </member>
        <member name="M:nom.tam.fits.Fits.ReadHDU">
            <summary>Read the next HDU on the default input stream.</summary>
            <returns>The HDU read, or null if an EOF was detected.
            Note that null is only returned when the EOF is detected immediately
            at the beginning of reading the HDU.</returns>
        </member>
        <member name="M:nom.tam.fits.Fits.SkipHDU(System.Int32)">
            <summary>Skip HDUs on the associate input stream.</summary>
            <param name="n">The number of HDUs to be skipped.</param>
        </member>
        <member name="M:nom.tam.fits.Fits.SkipHDU">
            <summary>Skip the next HDU on the default input stream.</summary>
        </member>
        <member name="M:nom.tam.fits.Fits.GetHDU(System.Int32)">
            <summary>Return the n'th HDU.
            If the HDU is already read simply return a pointer to the
            cached data.  Otherwise read the associated stream
            until the n'th HDU is read.
            </summary>
            <param name="n">The index of the HDU to be read.  The primary HDU is index 0.</param>
            <returns> The n'th HDU or null if it could not be found.</returns>
        </member>
        <member name="M:nom.tam.fits.Fits.ReadToEnd">
            <summary>Read to the end of the associated input stream</summary>
        </member>
        <member name="M:nom.tam.fits.Fits.Size">
            <summary>Return the number of HDUs in the Fits object.   If the
            FITS file is associated with an external stream make
            sure that we have exhausted the stream.
            </summary>
            <returns>number of HDUs.</returns>
            <deprecated>The meaning of size of ambiguous.  Use</deprecated>
        </member>
        <member name="M:nom.tam.fits.Fits.AddHDU(nom.tam.fits.BasicHDU)">
            <summary>Add an HDU to the Fits object.  Users may intermix
            calls to functions which read HDUs from an associated
            input stream with the addHDU and insertHDU calls,
            but should be careful to understand the consequences.
            </summary>
            <param name="myHDU"> The HDU to be added to the end of the FITS object.</param>
        </member>
        <member name="M:nom.tam.fits.Fits.InsertHDU(nom.tam.fits.BasicHDU,System.Int32)">
            <summary>Insert a FITS object into the list of HDUs.</summary>
            <param name="myHDU">The HDU to be inserted into the list of HDUs.</param>
            <param name="n">The location at which the HDU is to be inserted.</param>
        </member>
        <member name="M:nom.tam.fits.Fits.DeleteHDU(System.Int32)">
            <summary>Delete an HDU from the HDU list.</summary>
            <param name="n"> The index of the HDU to be deleted.
            If n is 0 and there is more than one HDU present, then
            the next HDU will be converted from an image to
            primary HDU if possible.  If not a dummy header HDU
            will then be inserted.</param>
        </member>
        <member name="M:nom.tam.fits.Fits.Write(System.IO.Stream)">
            <summary>Write a Fits Object to an external Stream.  The stream is left open.</summary>
            <param name="dos">A DataOutput stream</param>
        </member>
        <member name="M:nom.tam.fits.Fits.Read(System.IO.Stream)">
            <summary>Read a FITS file from an InputStream object.</summary>
            <param name="is">The InputStream stream whence the FITS information is found.</param>
        </member>
        <member name="M:nom.tam.fits.Fits.Close">
            <summary>
            
            </summary>
        </member>
        <member name="M:nom.tam.fits.Fits.CurrentSize">
            <summary>Get the current number of HDUs in the Fits object.</summary>
            <returns>The number of HDU's in the object.</returns>
            <deprecated>See getNumberOfHDUs()</deprecated>
        </member>
        <member name="M:nom.tam.fits.Fits.MakeHDU(nom.tam.fits.Header)">
            <summary>Create an HDU from the given header.</summary>
            <param name="h"> The header which describes the FITS extension</param>
        </member>
        <member name="M:nom.tam.fits.Fits.MakeHDU(System.Object)">
            <summary>Create an HDU from the given data kernel.</summary>
            <param name="o">The data to be described in this HDU.</param>
        </member>
        <member name="M:nom.tam.fits.Fits.MakeHDU(nom.tam.fits.Data)">
            <summary>Create an HDU from the given Data.</summary>
            <param name="datum">The data to be described in this HDU.</param>
        </member>
        <member name="M:nom.tam.fits.Fits.SetChecksum(nom.tam.fits.BasicHDU)">
            <summary>Add or update the CHECKSUM keyword.</summary>
            <param name="hdu">The primary or other header to get the current DATE.</param>
        </member>
        <member name="M:nom.tam.fits.Fits.SetChecksum">
            <summary>Add or Modify the CHECKSUM keyword in all headers.</summary>
        </member>
        <member name="M:nom.tam.fits.Fits.Checksum(System.Byte[])">
            <summary>
            Calculate the Seaman-Pence 32-bit 1's complement checksum over the byte stream. The option
            to start from an intermediate checksum accumulated over another previous
            byte stream is not implemented.
            The implementation accumulates in two 64-bit integer values the two low-order and the two
            high-order bytes of adjacent 4-byte groups. A carry-over of bits is never done within the main
            loop (only once at the end at reduction to a 32-bit positive integer) since an overflow
            of a 64-bit value (signed, with maximum at 2^63-1) by summation of 16-bit values could only
            occur after adding approximately 140G short values (=2^47) (280GBytes) or more. We assume
            for now that this routine here is never called to swallow FITS files of that size or larger.
            </summary>
            <param name="data">The byte sequence.</param>
            <return>The 32bit checksum in the range from 0 to 2^32-1. </return>
        </member>
        <!-- Badly formed XML comment ignored for member "M:nom.tam.fits.Fits.ChecksumEnc(System.Int64,System.Boolean)" -->
        <member name="P:nom.tam.fits.FitsDate.FitsDateString">
            <summary>Return the current date in FITS date format</summary>
        </member>
        <member name="M:nom.tam.fits.FitsDate.#ctor(System.String)">
            <summary> Convert a FITS date string to a Java <CODE>Date</CODE> object.</summary>
            <param name="dStr">the FITS date</param>
            <returns>either <CODE>null</CODE> or a Date object</returns>
            <exception cref="T:nom.tam.fits.FitsException">if <CODE>dStr</CODE> does not contain a valid FITS date.</exception>
        </member>
        <member name="M:nom.tam.fits.FitsDate.ToDate">
            <summary>Get a Date object corresponding to this FITS date.</summary>
            <returns> The Date object.</returns>
        </member>
        <member name="M:nom.tam.fits.FitsDate.GetFitsDateString">
            <summary> Return the current date in FITS date format.</summary>
        </member>
        <member name="M:nom.tam.fits.FitsDate.GetFitsDateString(System.DateTime)">
            <summary>Create FITS format date string Date object.</summary>
            <param name="epoch">The epoch to be converted to FITS format.</param>
        </member>
        <member name="M:nom.tam.fits.FitsDate.GetFitsDateString(System.DateTime,System.Boolean)">
            <summary>Create FITS format date string. Note that the date is not rounded.</summary>
            <param name="epoch">The epoch to be converted to FITS format.</param>
            <param name="timeOfDay">Should time of day information be included?</param>
        </member>
        <member name="M:nom.tam.fits.FitsDate.ToString">
            <summary>
            Converts the buffer contents into String
            </summary>
            <returns></returns>
        </member>
        <member name="T:nom.tam.fits.FitsElement">
            <summary>This inteface describes allows uses to easily perform
            basic I/O operations
            on a FITS element.
            </summary>
        </member>
        <member name="P:nom.tam.fits.FitsElement.FileOffset">
            <summary>Get the byte at which this element begins.
            This is only available if the data is originally read from
            a random access medium.
            </summary>
        </member>
        <member name="P:nom.tam.fits.FitsElement.Size">
            <summary>The size of this element in bytes</summary>
        </member>
        <member name="M:nom.tam.fits.FitsElement.Read(nom.tam.util.ArrayDataIO)">
            <summary>Read the contents of the element from an input source.</summary>
            <param name="in_Renamed">input source.</param>
        </member>
        <member name="M:nom.tam.fits.FitsElement.Write(nom.tam.util.ArrayDataIO)">
            <summary>Write the contents of the element to a data sink.</summary>
            <param name="out_Renamed">The data sink.</param>
        </member>
        <member name="M:nom.tam.fits.FitsElement.Rewrite">
            <summary>Rewrite the contents of the element in place.
            The data must have been orignally read from a random
            access device, and the size of the element may not have changed.
            </summary>
        </member>
        <member name="T:nom.tam.fits.FitsFactory">
            <summary>This class contains the code which
            associates particular FITS types with header
            and data configurations.  It comprises
            a set of Factory methods which call
            appropriate methods in the HDU classes.
            If -- God forbid -- a new FITS HDU type were
            created, then the XXHDU, XXData classes would
            need to be added and this file modified but
            no other changes should be needed in the FITS libraries.
            </summary>
        </member>
        <member name="P:nom.tam.fits.FitsFactory.UseAsciiTables">
            <summary>Indicate whether ASCII tables should be used where feasible.</summary>
        </member>
        <member name="P:nom.tam.fits.FitsFactory.UseHierarch">
            <summary>Are we processing HIERARCH style keywords</summary>
            <summary>Enable/Disable hierarchical keyword processing.</summary>
        </member>
        <member name="M:nom.tam.fits.FitsFactory.DataFactory(nom.tam.fits.Header)">
            <summary>Given a Header return an appropriate datum.</summary>
        </member>
        <member name="M:nom.tam.fits.FitsFactory.HDUFactory(System.Object)">
            <summary>Given an object, create the appropriate FITS header to describe it.</summary>
            <param name="o">The object to be described.</param>
        </member>
        <member name="M:nom.tam.fits.FitsFactory.HDUFactory(nom.tam.fits.Header,nom.tam.fits.Data)">
            <summary>Given Header and data objects return the appropriate type of HDU.</summary>
        </member>
        <member name="T:nom.tam.fits.FitsHeap">
            <summary>This class supports the FITS heap.  This
            is currently used for variable length columns
            in binary tables.</summary>
        </member>
        <member name="P:nom.tam.fits.FitsHeap.Rewriteable">
            <summary>
            Returns if stream is rewritable
            </summary>
        </member>
        <member name="P:nom.tam.fits.FitsHeap.Offset">
            <summary>Get the current offset within the heap.</summary>
        </member>
        <member name="P:nom.tam.fits.FitsHeap.Size">
            <summary>Return the size of the heap using the more bean compatbile format.</summary>
        </member>
        <member name="P:nom.tam.fits.FitsHeap.FileOffset">
            <summary>Get the file offset of the heap.</summary>
        </member>
        <member name="F:nom.tam.fits.FitsHeap.heap">
            <summary>The storage buffer</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:nom.tam.fits.FitsHeap.heapSize" -->
        <member name="F:nom.tam.fits.FitsHeap.fileOffset">
            <summary>The offset within a file where the heap begins</summary>
        </member>
        <member name="F:nom.tam.fits.FitsHeap.expanded">
            <summary> Has the heap ever been expanded?</summary>
        </member>
        <member name="F:nom.tam.fits.FitsHeap.input">
            <summary>The stream the last read used</summary>
        </member>
        <member name="F:nom.tam.fits.FitsHeap.heapOffset">
            <summary>Our current offset into the heap.  When we read from 
            the heap we use a byte array input stream.  So long 
            as we continue to read further into the heap, we can 
            continue to use the same stream, but we need to 
            recreate the stream whenever we skip backwards.</summary>
        </member>
        <member name="F:nom.tam.fits.FitsHeap.bstr">
            <summary>A stream used to read the heap data</summary>
        </member>
        <member name="M:nom.tam.fits.FitsHeap.#ctor(System.Int32)">
            <summary>Create a heap of a given size.</summary>
        </member>
        <member name="M:nom.tam.fits.FitsHeap.Read(nom.tam.util.ArrayDataIO)">
            <summary>Read the heap</summary>
        </member>
        <member name="M:nom.tam.fits.FitsHeap.Write(nom.tam.util.ArrayDataIO)">
            <summary>Write the heap</summary>
        </member>
        <member name="M:nom.tam.fits.FitsHeap.Rewrite">
            <summary>Attempt to rewrite the heap with the current contents.
            Note that no checking is done to make sure that the
            heap does not extend past its prior boundaries.</summary>
        </member>
        <member name="M:nom.tam.fits.FitsHeap.GetData(System.Int32,System.Object)">
            <summary>Get data from the heap.</summary>
            <param name="offset">The offset at which the data begins.</param>
            <param name="array"> The array to be extracted.</param>
        </member>
        <member name="M:nom.tam.fits.FitsHeap.ExpandHeap(System.Int32)">
            <summary>Check if the Heap can accommodate a given requirement. If not expand the heap.</summary>
        </member>
        <member name="M:nom.tam.fits.FitsHeap.PutData(System.Object)">
            <summary>Add some data to the heap.</summary>
        </member>
        <member name="M:nom.tam.fits.FitsHeap.GetSize">
            <summary>Return the size of the Heap.</summary>
        </member>
        <member name="T:nom.tam.fits.FitsUtil">
            <summary>This class comprises static
            utility functions used throughout
            the FITS classes.
            </summary>
        </member>
        <member name="M:nom.tam.fits.FitsUtil.Reposition(System.Object,System.Int64)">
            <summary>Reposition a random access stream to a requested offset</summary>
        </member>
        <member name="M:nom.tam.fits.FitsUtil.FindOffset(System.Object)">
            <summary>Find out where we are in a random access file</summary>
        </member>
        <member name="M:nom.tam.fits.FitsUtil.Padding(System.Int32)">
            <summary>How many bytes are needed to fill the last 2880 block?</summary>
        </member>
        <member name="M:nom.tam.fits.FitsUtil.Padding(System.Int64)">
            <summary>How many bytes are needed to fill the last 2880 block?</summary>
        </member>
        <member name="M:nom.tam.fits.FitsUtil.AddPadding(System.Int32)">
            <summary>Total size of blocked FITS element</summary>
        </member>
        <member name="M:nom.tam.fits.FitsUtil.IsCompressed(System.String)">
            <summary>Check if a file seems to be compressed.</summary>
        </member>
        <member name="M:nom.tam.fits.FitsUtil.MaxLength(System.String[])">
            <summary>Get the maximum length of a String in a String array.</summary>
        </member>
        <member name="M:nom.tam.fits.FitsUtil.StringsToByteArray(System.String[],System.Int32)">
            <summary>Copy an array of Strings to bytes.</summary>
        </member>
        <member name="M:nom.tam.fits.FitsUtil.ByteArrayToStrings(System.Byte[],System.Int32)">
            <summary>Convert bytes to Strings</summary>
        </member>
        <member name="M:nom.tam.fits.FitsUtil.BooleanToByte(System.Boolean[])">
            <summary>Convert an array of booleans to bytes</summary>
        </member>
        <member name="M:nom.tam.fits.FitsUtil.ByteToBoolean(System.Byte[])">
            <summary>Convert an array of bytes to booleans</summary>
        </member>
        <member name="M:nom.tam.fits.FitsUtil.GetURLStream(System.String,System.Int32)">
            <summary>
            Get a stream to a URL accommodating possible redirections.
            Note that if a redirection request points to a different
            protocol than the original request, then the redirection
            is not handled automatically.
            </summary>
        </member>
        <member name="T:nom.tam.fits.Header">
            <summary>This class describes methods to access and manipulate the header
            for a FITS HDU. This class does not include code specific
            to particular types of HDU.
            </summary>
        </member>
        <member name="P:nom.tam.fits.Header.Rewriteable">
            <summary>Can the header be rewritten without rewriting the entire file?</summary>
        </member>
        <member name="P:nom.tam.fits.Header.NumberOfCards">
            <summary>Find the number of cards in the header</summary>
        </member>
        <member name="P:nom.tam.fits.Header.FileOffset">
            <summary>Get the offset of this header</summary>
        </member>
        <member name="P:nom.tam.fits.Header.DataSize">
            <summary>Return the size of the data including any needed padding.</summary>
            <returns> the data segment size including any needed padding.</returns>
        </member>
        <member name="P:nom.tam.fits.Header.Size">
            <summary>Get the size of the header in bytes</summary>
        </member>
        <member name="P:nom.tam.fits.Header.ValidHeader">
            <summary>Is this a valid header.</summary>
            <returns> <CODE>true</CODE> for a valid header, <CODE>false</CODE> otherwise.</returns>
        </member>
        <member name="P:nom.tam.fits.Header.Simple">
            <summary>
            Set the SIMPLE keyword to the given value.
            </summary>
        </member>
        <member name="P:nom.tam.fits.Header.Xtension">
            <summary>Set the XTENSION keyword to the given value. "IMAGE" and "BINTABLE" are supported.</summary>
        </member>
        <member name="P:nom.tam.fits.Header.Bitpix">
            <summary>Set the BITPIX value for the header.</summary>
            <param name="val.."> The following values are permitted by FITS conventions:
            <ul>
            <li> 8  -- signed bytes data.  Also used for tables.</li>
            <li> 16 -- signed short data.</li>
            <li> 32 -- signed int data.</li>
            <li> -32 -- IEEE 32 bit floating point numbers.</li>
            <li> -64 -- IEEE 64 bit floating point numbers.</li>
            </ul>
            These Fits classes also support BITPIX=64 in which case data
            is signed 64 bit long data.</param>
        </member>
        <member name="P:nom.tam.fits.Header.Naxes">
            <summary>Set the value of the NAXIS keyword (The dimensionality of the data)</summary>
        </member>
        <member name="F:nom.tam.fits.Header.cards">
            <summary>The actual header data stored as a HashedList of HeaderCards.</summary>
        </member>
        <member name="F:nom.tam.fits.Header.cursor">
            <summary>This cursor allows one to run through the list.</summary>
        </member>
        <member name="F:nom.tam.fits.Header.fileOffset">
            <summary>Offset of this Header in the FITS file</summary>
        </member>
        <member name="F:nom.tam.fits.Header.oldSize">
            <summary>Number of cards in header last time it was read</summary>
        </member>
        <member name="F:nom.tam.fits.Header.input">
            <summary>Input descriptor last time header was read</summary>
        </member>
        <member name="M:nom.tam.fits.Header.#ctor">
            <summary>Create an empty header</summary>
        </member>
        <member name="M:nom.tam.fits.Header.#ctor(nom.tam.util.ArrayDataIO)">
            <summary>Create a header and populate it from the input stream</summary>
            <param name="is_Renamed"> The input stream where header information is expected.</param>
        </member>
        <member name="M:nom.tam.fits.Header.#ctor(System.String[])">
            <summary>Create a header and initialize it with a vector of strings.</summary>
            <param name="newCards">Card images to be placed in the header.</param>
        </member>
        <member name="M:nom.tam.fits.Header.#ctor(nom.tam.fits.Data)">
            <summary>Create a header which points to the given data object.</summary>
            <param name="o">The data object to be described.</param>
            <exception cref="T:nom.tam.fits.FitsException"> FitsException if the data was not valid for this header.</exception>
        </member>
        <member name="M:nom.tam.fits.Header.MakeData">
            <summary>Create the data element corresponding to the current header</summary>
        </member>
        <member name="M:nom.tam.fits.Header.AddCard(nom.tam.fits.HeaderCard)">
            <summary>Adds card to the end of the HeaderCard list</summary>
            <param name="card">The card to be added</param>
        </member>
        <member name="M:nom.tam.fits.Header.AddValue(System.String,System.String,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and adds the new card to the end of the HeaderCard list 
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.AddValue(System.String,System.Boolean,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and adds the new card to the end of the HeaderCard list 
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.AddValue(System.String,System.Int32,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and adds the new card to the end of the HeaderCard list 
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.AddValue(System.String,System.Single,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and adds the new card to the end of the HeaderCard list 
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.AddValue(System.String,System.Int64,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and adds the new card to the end of the HeaderCard list 
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.AddValue(System.String,System.Double,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and adds the new card to the end of the HeaderCard list 
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.AddComment(System.String)">
            <summary>
            Creates a new HeaderCard to accommodate comment,
            and adds the new card to the end of the HeaderCard list
            </summary>
            <param name="comment">The comment of the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.AddHistory(System.String)">
            <summary>
            Creates a new HeaderCard to accommodate history,
            and adds the new card to the end of the HeaderCard list
            </summary>
            <param name="history"></param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertCard(nom.tam.fits.HeaderCard,System.Int32)">
            <summary>
            Inserts card at the pos'th position in the HeaderCard list.
            If pos is out of the bounds of the list,
            card will be added to the end of the list.
            </summary>
            <param name="card">The HeaderCard to be inserted</param>
            <param name="pos">The list position into which to insert card</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.String,System.String,System.Int32)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new card in the pos'th position in the HeaderCard list.
            If pos is out of the bounds of the list,
            the new HeaderCard will be added to the end of the list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="pos">The list position into which to insert the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Boolean,System.String,System.Int32)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new card in the pos'th position in the HeaderCard list.
            If pos is out of the bounds of the list,
            the new HeaderCard will be added to the end of the list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="pos">The list position into which to insert the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Int32,System.String,System.Int32)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new card in the pos'th position in the HeaderCard list.
            If pos is out of the bounds of the list,
            the new HeaderCard will be added to the end of the list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="pos">The list position into which to insert the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Single,System.String,System.Int32)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new card in the pos'th position in the HeaderCard list.
            If pos is out of the bounds of the list,
            the new HeaderCard will be added to the end of the list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="pos">The list position into which to insert the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Int64,System.String,System.Int32)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new card in the pos'th position in the HeaderCard list.
            If pos is out of the bounds of the list,
            the new HeaderCard will be added to the end of the list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="pos">The list position into which to insert the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Double,System.String,System.Int32)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new card in the pos'th position in the HeaderCard list.
            If pos is out of the bounds of the list,
            the new HeaderCard will be added to the end of the list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="pos">The list position into which to insert the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertComment(System.String,System.Int32)">
            <summary>
            Creates a new HeaderCard to accommodate comment,
            and inserts the new card in the pos'th position in the HeaderCard list.
            If pos is out of the bounds of the list,
            the new HeaderCard will be added to the end of the list.
            </summary>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="pos">The list position into which to insert the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertHistory(System.String,System.Int32)">
            <summary>
            Creates a new HeaderCard to accommodate comment,
            and inserts the new card in the pos'th position in the HeaderCard list.
            If pos is out of the bounds of the list,
            the new HeaderCard will be added to the end of the list.
            </summary>
            <param name="history">The history of the new HeaderCard</param>
            <param name="pos">The list position into which to insert the new HeaderCard</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertCard(nom.tam.fits.HeaderCard,System.String)">
            <summary>
            Inserts card in front of the HeaderCard associated with key posKey.
            If there is no HeaderCard associated with posKey,
            card is added to the end of the HeaderCard list
            </summary>
            <param name="card">The card to be inserted</param>
            <param name="posKey">The key of the HeaderCard in front of which card is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new card in front of the HeaderCard associated with key posKey.
            If there is no HeaderCard associated with posKey,
            the new card is added to the end of the HeaderCard list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posKey">The key of the HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Boolean,System.String,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new card in front of the HeaderCard associated with key posKey.
            If there is no HeaderCard associated with posKey,
            the new card is added to the end of the HeaderCard list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posKey">The key of the HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Int32,System.String,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new card in front of the HeaderCard associated with key posKey.
            If there is no HeaderCard associated with posKey,
            the new card is added to the end of the HeaderCard list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posKey">The key of the HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Single,System.String,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new card in front of the HeaderCard associated with key posKey.
            If there is no HeaderCard associated with posKey,
            the new card is added to the end of the HeaderCard list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posKey">The key of the HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Int64,System.String,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new card in front of the HeaderCard associated with key posKey.
            If there is no HeaderCard associated with posKey,
            the new card is added to the end of the HeaderCard list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posKey">The key of the HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Double,System.String,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new card in front of the HeaderCard associated with key posKey.
            If there is no HeaderCard associated with posKey,
            the new card is added to the end of the HeaderCard list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posKey">The key of the HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertComment(System.String,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate comment,
            and inserts the new card in front of the HeaderCard associated with key posKey.
            If there is no HeaderCard associated with posKey,
            the new card is added to the end of the HeaderCard list.
            </summary>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posKey">The key of the HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertHistory(System.String,System.String)">
            <summary>
            Creates a new HeaderCard to accommodate history,
            and inserts the new card in front of the HeaderCard associated with key posKey.
            If there is no HeaderCard associated with posKey,
            the new card is added to the end of the HeaderCard list.
            </summary>
            <param name="history">The history of the new HeaderCard</param>
            <param name="posKey">The key of the HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertCard(nom.tam.fits.HeaderCard,nom.tam.fits.HeaderCard)">
            <summary>
            Inserts card in front of posCard in the HeaderCard list.
            If posCard is null, card is added to the end of the list.
            </summary>
            <param name="card">The HeaderCard to be inserted</param>
            <param name="posCard">The HeaderCard in front of which card is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.String,System.String,nom.tam.fits.HeaderCard)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new HeaderCard in front of posCard in the HeaderCard list.
            If posCard is null, the new HeaderCard is added to the end of the list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posCard">The HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Boolean,System.String,nom.tam.fits.HeaderCard)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new HeaderCard in front of posCard in the HeaderCard list.
            If posCard is null, the new HeaderCard is added to the end of the list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posCard">The HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Int32,System.String,nom.tam.fits.HeaderCard)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new HeaderCard in front of posCard in the HeaderCard list.
            If posCard is null, the new HeaderCard is added to the end of the list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posCard">The HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Single,System.String,nom.tam.fits.HeaderCard)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new HeaderCard in front of posCard in the HeaderCard list.
            If posCard is null, the new HeaderCard is added to the end of the list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posCard">The HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Int64,System.String,nom.tam.fits.HeaderCard)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new HeaderCard in front of posCard in the HeaderCard list.
            If posCard is null, the new HeaderCard is added to the end of the list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posCard">The HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertValue(System.String,System.Double,System.String,nom.tam.fits.HeaderCard)">
            <summary>
            Creates a new HeaderCard to accommodate key, val, and comment,
            and inserts the new HeaderCard in front of posCard in the HeaderCard list.
            If posCard is null, the new HeaderCard is added to the end of the list.
            </summary>
            <param name="key">The key of the new HeaderCard</param>
            <param name="val">The value of the new HeaderCard</param>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posCard">The HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertComment(System.String,nom.tam.fits.HeaderCard)">
            <summary>
            Creates a new HeaderCard to accommodate comment,
            and inserts the new HeaderCard in front of posCard in the HeaderCard list.
            If posCard is null, the new HeaderCard is added to the end of the list.
            </summary>
            <param name="comment">The comment of the new HeaderCard</param>
            <param name="posCard">The HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertHistory(System.String,nom.tam.fits.HeaderCard)">
            <summary>
            Creates a new HeaderCard to accommodate comment,
            and inserts the new HeaderCard in front of posCard in the HeaderCard list.
            If posCard is null, the new HeaderCard is added to the end of the list.
            </summary>
            <param name="history">The history of the new HeaderCard</param>
            <param name="posCard">The HeaderCard in front of which the new HeaderCard is to be inserted</param>
        </member>
        <member name="M:nom.tam.fits.Header.RemoveCard(System.Int32)">
            <summary>
            Removes the HeaderCard at position index in the HeaderCard list.
            Remember that each call to this method shifts the index of subsequent cards in the list.
            </summary>
            <param name="index">The position in the HeaderCard list of the HeaderCard to be removed</param>
        </member>
        <member name="M:nom.tam.fits.Header.RemoveCard(System.String)">
            <summary>
            Removes the HeaderCard associated with key
            </summary>
            <param name="key">The key of the HeaderCard to be removed</param>
        </member>
        <member name="M:nom.tam.fits.Header.RemoveCard(nom.tam.fits.HeaderCard)">
            <summary>
            Removes card from the HeaderCard list
            </summary>
            <param name="card">The card to be removed</param>
        </member>
        <member name="M:nom.tam.fits.Header.InsertCommentStyle(System.String,System.String)">
             <summary>
            Add a line to the header using the COMMENT style, i.e., no '='
             in column 9.
             </summary>
             <param name="header">The comment style header.</param>
             <param name="value_Renamed">A string to follow the header.</param>
             <exception cref="T:nom.tam.fits.HeaderCardException"> HeaderCardException If the parameters cannot build a
             valid FITS card.</exception>
        </member>
        <member name="M:nom.tam.fits.Header.DeleteKey(System.String)">
            <summary>Delete the card associated with the given key.
            Nothing occurs if the key is not found.</summary>
            <param name="key">The header key.</param>
            FIX THIS
            either kill this or RemoveCard
        </member>
        <!-- Badly formed XML comment ignored for member "M:nom.tam.fits.Header.ContainsKey(System.String)" -->
        <member name="M:nom.tam.fits.Header.AddLine(nom.tam.fits.HeaderCard)">
            <summary>Add a card image to the header.</summary>
            <param name="fcard">The card to be added.</param>
            FIX THIS
        </member>
        <member name="M:nom.tam.fits.Header.AddLine(System.String)">
            <summary>Add a card image to the header.</summary>
            <param name="card">The card to be added.</param>
            <exception cref="T:nom.tam.fits.HeaderCardException"> HeaderCardException If the card is not valid.</exception>
        </member>
        <member name="M:nom.tam.fits.Header.UpdateLine(System.String,nom.tam.fits.HeaderCard)">
            <summary>Update a line in the header.</summary>
            <param name="key">The key of the card to be replaced.</param>
            <param name="card">A new card.</param>
        </member>
        <member name="M:nom.tam.fits.Header.UpdateLines(nom.tam.fits.Header)">
            <summary>
            Overwrite the lines in the header.
            Add the new PHDU header to the current one. If keywords appear
            twice, the new value and comment overwrite the current contents.
            </summary>
            <param name="newHdr">the list of new header data lines to replace the current ones.</param>
        </member>
        <member name="M:nom.tam.fits.Header.GetCursor">
            <summary>Get a cursor over the header cards</summary>
            KILL THIS METHOD
        </member>
        <member name="M:nom.tam.fits.Header.FindCard(System.String)">
            <summary>Find the card associated with a given key.
            If found this sets the mark to the card, otherwise it
            unsets the mark.</summary>
            <param name="key">The header key.</param>
            <returns> <CODE>null</CODE> if the keyword could not be found;
            return the HeaderCard object otherwise.</returns>
            FIX THIS
        </member>
        <member name="M:nom.tam.fits.Header.ReplaceKey(System.String,System.String)">
            <summary>Replace the key with a new key.  Typically this is used
            when deleting or inserting columns so that TFORMx -> TFORMx-1</summary>
            <param name="oldKey">The old header keyword.</param>
            <param name="newKey">the new header keyword.</param>
            <returns> <CODE>true</CODE> if the card was replaced.</returns>
            <exception cref="T:nom.tam.fits.HeaderCardException"> HeaderCardException If <CODE>newKey</CODE> is not a
            valid FITS keyword.</exception>
        </member>
        <member name="M:nom.tam.fits.Header.GetEnumerator">
            <summary>
            Gets cursor
            </summary>
            <returns></returns>
        </member>
        <member name="M:nom.tam.fits.Header.DumpHeader(System.IO.TextWriter)">
            <summary>Print the header to a given stream.</summary>
            <param name="ps">the stream to which the card images are dumped.</param>
        </member>
        <member name="M:nom.tam.fits.Header.GetCard(System.Int32)">
            <summary>Get the n'th card image in the header</summary>
            <returns>the card image; return <CODE>null</CODE> if the n'th card does not exist.</returns>
            <deprecated> A cursor should be used for sequential access to the header.</deprecated>
            KILL THIS METHOD
        </member>
        <member name="M:nom.tam.fits.Header.PositionAfterIndex(System.String,System.Int32)">
            <summary>Find the end of a set of keywords describing a column or axis
            (or anything else terminated by an index.  This routine leaves
            the header ready to add keywords after any existing keywords
            with the index specified.  The user should specify a
            prefix to a keyword that is guaranteed to be present.</summary>
            MAN WOULD IT BE GREAT TO GET RID OF THIS METHOD
        </member>
        <member name="M:nom.tam.fits.Header.NextCard">
            <summary>Get the next card in the Header using the current cursor</summary>
        </member>
        <member name="M:nom.tam.fits.Header.TrueDataSize">
            <summary>Calculate the unpadded size of the data segment from the header information.</summary>
            <returns> the unpadded data segment size.</returns>
        </member>
        <member name="M:nom.tam.fits.Header.HeaderSize">
            <summary>Return the size of the header data including padding.</summary>
            <returns> the header size including any needed padding.</returns>
        </member>
        <member name="M:nom.tam.fits.Header.GetIntValue(System.String,System.Int32)">
            <summary>Get the value associated with the key as an int.</summary>
            <param name="key">The header key.</param>
            <param name="dft">The value to be returned if the key is not found.</param>
        </member>
        <member name="M:nom.tam.fits.Header.GetIntValue(System.String)">
            <summary>Get the <CODE>int</CODE> value associated with the given key.</summary>
            <param name="key">The header key.</param>
            <returns> The associated value or 0 if not found.</returns>
        </member>
        <member name="M:nom.tam.fits.Header.GetLongValue(System.String)">
            <summary>Get the <CODE>long</CODE> value associated with the given key.</summary>
            <param name="key">The header key.</param>
            <returns> The associated value or 0 if not found.</returns>
        </member>
        <member name="M:nom.tam.fits.Header.GetLongValue(System.String,System.Int64)">
            <summary>Get the <CODE>long</CODE> value associated with the given key.</summary>
            <param name="key">The header key.</param>
            <param name="dft">The default value to be returned if the key cannot be found.</param>
            <returns> the associated value.</returns>
        </member>
        <member name="M:nom.tam.fits.Header.GetFloatValue(System.String,System.Single)">
            <summary>Get the <CODE>float</CODE> value associated with the given key.</summary>
            <param name="key">The header key.</param>
            <param name="dft">The value to be returned if the key is not found.</param>
        </member>
        <member name="M:nom.tam.fits.Header.GetFloatValue(System.String)">
            <summary>Get the <CODE>float</CODE> value associated with the given key.</summary>
            <param name="key">The header key.</param>
            <returns> The associated value or 0.0 if not found.</returns>
        </member>
        <member name="M:nom.tam.fits.Header.GetDoubleValue(System.String)">
            <summary>Get the <CODE>double</CODE> value associated with the given key.</summary>
            <param name="key">The header key.</param>
            <returns>The associated value or 0.0 if not found.</returns>
        </member>
        <member name="M:nom.tam.fits.Header.GetDoubleValue(System.String,System.Double)">
            <summary>Get the <CODE>double</CODE> value associated with the given key.</summary>
            <param name="key">The header key.</param>
            <param name="dft">The default value to return if the key cannot be found.</param>
            <returns> the associated value.</returns>
        </member>
        <member name="M:nom.tam.fits.Header.GetBooleanValue(System.String)">
            <summary>Get the <CODE>boolean</CODE> value associated with the given key.</summary>
            <param name="key">header key.</param>
            <returns> The value found, or false if not found or if the keyword is not a logical keyword.</returns>
        </member>
        <member name="M:nom.tam.fits.Header.GetBooleanValue(System.String,System.Boolean)">
            <summary>Get the <CODE>boolean</CODE> value associated with the given key.</summary>
            <param name="key">The header key.</param>
            <param name="dft">The value to be returned if the key cannot be found
            or if the parameter does not seem to be a boolean.</param>
            <returns> the associated value.</returns>
        </member>
        <member name="M:nom.tam.fits.Header.GetStringValue(System.String)">
            <summary>Get the <CODE>String</CODE> value associated with the given key.</summary>
            <param name="key">The header key.</param>
            <returns> The associated value or null if not found or if the value is not a string.</returns>
        </member>
        <member name="M:nom.tam.fits.Header.ReadHeader(nom.tam.util.ArrayDataIO)">
            <summary>Create a header by reading the information from the input stream.</summary>
            <param name="dis">The input stream to read the data from.</param>
            <returns> <CODE>null</CODE> if there was a problem with the header;
            otherwise return the header read from the input stream.</returns>
        </member>
        <member name="M:nom.tam.fits.Header.Read(nom.tam.util.ArrayDataIO)">
            <summary>Read a stream for header data.</summary>
            <param name="dis">The input stream to read the data from.</param>
            <returns> <CODE>null</CODE> if there was a problem with the header;
            otherwise return the header read from the input stream.</returns>
            <exception cref="T:nom.tam.fits.TruncatedFileException"> </exception>"
        </member>
        <member name="M:nom.tam.fits.Header.Write(nom.tam.util.ArrayDataIO)">
            <summary>Write the current header (including any needed padding) to the
            output stream.</summary>
            <param name="dos">The output stream to which the data is to be written.</param>
            <exception cref="T:nom.tam.fits.FitsException">FitsException if the header could not be written.</exception>
        </member>
        <member name="M:nom.tam.fits.Header.Rewrite">
            <summary>Rewrite the header.</summary>
        </member>
        <member name="M:nom.tam.fits.Header.NullImage">
            <summary>Create a header for a null image.</summary>
        </member>
        <member name="M:nom.tam.fits.Header.SetNaxis(System.Int32,System.Int32)">
            <summary>Set the dimension for a given axis.</summary>
            <param name="axis">The axis being set.</param>
            <param name="dim"> The dimension</param>
        </member>
        <member name="M:nom.tam.fits.Header.CheckBeginning">
            <summary>Ensure that the header begins with
            a valid set of keywords.  Note that we
            do not check the values of these keywords.</summary>
        </member>
        <member name="M:nom.tam.fits.Header.CardCheck(System.String)">
            <summary>Check if the given key is the next one available in the header.</summary>
        </member>
        <member name="M:nom.tam.fits.Header.CheckEnd">
            <summary>Ensure that the header has exactly one END keyword in
            the appropriate location.</summary>
        </member>
        <member name="T:nom.tam.fits.HeaderCard">
            <summary>This class describes methods to access and manipulate the individual
            cards for a FITS Header.</summary>
        </member>
        <member name="P:nom.tam.fits.HeaderCard.IsStringValue">
            <summary>Does this card contain a string value?</summary>
        </member>
        <member name="P:nom.tam.fits.HeaderCard.KeyValuePair">
            <summary>Is this a key/value card?</summary>
        </member>
        <member name="P:nom.tam.fits.HeaderCard.Key">
            <summary>Return the keyword from this card</summary>
        </member>
        <member name="P:nom.tam.fits.HeaderCard.Value">
            <summary>Return the value from this card</summary>
        </member>
        <member name="P:nom.tam.fits.HeaderCard.Comment">
            <summary>Return the comment from this card</summary>
        </member>
        <member name="F:nom.tam.fits.HeaderCard.key">
            <summary>The keyword part of the card (set to null if there's no keyword)</summary>
        </member>
        <member name="F:nom.tam.fits.HeaderCard.val">
            <summary>The value part of the card (set to null if there's no value)</summary>
        </member>
        <member name="F:nom.tam.fits.HeaderCard.comment">
            <summary>The comment part of the card (set to null if there's no comment)</summary>
        </member>
        <member name="F:nom.tam.fits.HeaderCard.nullable">
            <summary>Does this card represent a nullable field. ?</summary>
            KILL THIS FIELD
        </member>
        <member name="F:nom.tam.fits.HeaderCard.isString">
            <summary>A flag indicating whether or not this is a string value</summary>
        </member>
        <member name="F:nom.tam.fits.HeaderCard.MAX_KEYWORD_LENGTH">
            <summary>Maximum length of a FITS keyword field</summary>
        </member>
        <member name="F:nom.tam.fits.HeaderCard.MAX_VALUE_LENGTH">
            <summary>Maximum length of a FITS value field</summary>
        </member>
        <member name="F:nom.tam.fits.HeaderCard.space80">
            <summary>padding for building card images</summary>
        </member>
        <member name="M:nom.tam.fits.HeaderCard.#ctor(System.String,System.String,System.String,System.Boolean)">
            <summary>Create a HeaderCard from its component parts</summary>
            <param name="key">Keyword (null for a COMMENT)</param>
            <param name="value">Value</param>
            <param name="comment">Comment</param>
            <param name="nullable">Is this a nullable value card?</param>
            <exception cref="!:"> HeaderCardException for any invalid keyword or value</exception>
        </member>
        <member name="M:nom.tam.fits.HeaderCard.#ctor(System.String,System.String,System.Boolean)">
            <summary>Create a comment style card.
            This constructor builds a card which has no value.
            This may be either a comment style card in which case the
            nullable field should be false, or a value field which 
            has a null value, in which case the nullable field should be
            true.</summary>
            <param name="key">The key for the comment or nullable field.</param>
            <param name="comment">The comment.</param>
            <param name="nullable">Is this a nullable field or a comment-style card?</param>
        </member>
        <member name="M:nom.tam.fits.HeaderCard.#ctor(System.String,System.String,System.String)">
            <summary>Create a HeaderCard from its component parts</summary>
            <param name="key">keyword (null for a comment)</param>
            <param name="value">value (null for a comment or keyword without an '=')</param>
            <param name="comment">comment</param>
            <exception cref="!:"> HeaderCardException for any invalid keyword or value</exception>
        </member>
        <member name="M:nom.tam.fits.HeaderCard.#ctor(System.String,System.Boolean,System.String)">
            <summary>Create a HeaderCard from its component parts</summary>
            <param name="key">keyword (null for a comment)</param>
            <param name="value">value (null for a comment or keyword without an '=')</param>
            <param name="comment">comment</param>
            <exception cref="!:"> HeaderCardException for any invalid keyword</exception>
        </member>
        <member name="M:nom.tam.fits.HeaderCard.#ctor(System.String,System.Int32,System.String)">
            <summary>Create a HeaderCard from its component parts</summary>
            <param name="key">keyword (null for a comment)</param>
            <param name="value">value (null for a comment or keyword without an '=')</param>
            <param name="comment">comment</param>
            <exception cref="!:">HeaderCardException for any invalid keyword</exception>
        </member>
        <member name="M:nom.tam.fits.HeaderCard.#ctor(System.String,System.Single,System.String)">
            <summary>Create a HeaderCard from its component parts</summary>
            <param name="key">keyword (null for a comment)</param>
            <param name="value">value (null for a comment or keyword without an '=')</param>
            <param name="comment">comment</param>
            <exception cref="!:">HeaderCardException for any invalid keyword</exception>
        </member>
        <member name="M:nom.tam.fits.HeaderCard.#ctor(System.String,System.Int64,System.String)">
            <summary>Create a HeaderCard from its component parts</summary>
            <param name="key">keyword (null for a comment)</param>
            <param name="value">value (null for a comment or keyword without an '=')</param>
            <param name="comment">comment</param>
            <exception cref="!:"> HeaderCardException for any invalid keyword</exception>
        </member>
        <member name="M:nom.tam.fits.HeaderCard.#ctor(System.String,System.Double,System.String)">
            <summary>Create a HeaderCard from its component parts</summary>
            <param name="key">keyword (null for a comment)</param>
            <param name="value">value (null for a comment or keyword without an '=')</param>
            <param name="comment">comment</param>
            <exception cref="!:">HeaderCardException for any invalid keyword</exception>
        </member>
        <member name="M:nom.tam.fits.HeaderCard.DblString(System.Double)">
            <summary>
            Create a string from a double making sure that it's 
            not more than 20 characters long.
            Probably would be better if we had a way to override this
            since we can loose precision for some doubles.
            </summary>
        </member>
        <member name="M:nom.tam.fits.HeaderCard.#ctor(System.String)">
            <summary>Create a HeaderCard from a FITS card image</summary>
            <param name="card">the 80 character card image</param>
        </member>
        <member name="M:nom.tam.fits.HeaderCard.HierarchCard(System.String)">
            <summary>Process HIERARCH style cards...
            HIERARCH LEV1 LEV2 ...  value / comment
            The keyword for the card will be "HIERARCH.LEV1.LEV2..."
            The value will be the first token which starts with a non-alphabetic
            character (i.e., not A-Z or _).
            A '/' is assumed to start a comment.
            </summary>
        </member>
        <member name="M:nom.tam.fits.HeaderCard.GetToken(System.String,System.Int32)">
            <summary>Get the next token.  Can't use StringTokenizer
            since we sometimes need to know the position within
            the string.</summary>
        </member>
        <member name="M:nom.tam.fits.HeaderCard.ToString">
            <summary>Return the 80 character card image</summary>
        </member>
        <member name="T:nom.tam.fits.HeaderCardException">
            <summary>
            This Class handles header card exception.It extends FitsException
            </summary>
        </member>
        <member name="M:nom.tam.fits.HeaderCardException.#ctor">
            <summary>
            Constructor without any paramteres
            </summary>
        </member>
        <member name="M:nom.tam.fits.HeaderCardException.#ctor(System.String)">
            <summary>
            Constructor taking String as paramter
            </summary>
            <param name="s"></param>
        </member>
        <member name="T:nom.tam.fits.HeaderOrder">
            <summary>Sorts keywords before a header is written to ensure that required keywords come where they need to be.
            </summary> 
        </member>
        <member name="M:nom.tam.fits.HeaderOrder.Compare(System.Object,System.Object)">
            <summary>
            Which order should the cards indexed by these keys
            be written out?  This method assumes that the
            arguments are either the FITS Header keywords as
            strings, and some other type (or null) for comment
            style keywords.
            </summary>
            <returns>
            -1: if the first argument should be written first.
            1:  if the second argument should be written first.
            0:  if either is legal.
            </returns>
        </member>
        <member name="M:nom.tam.fits.HeaderOrder.EqualsTo(System.Object,System.Object)">
            <summary>Can two cards be exchanged when being written out?</summary>
        </member>
        <member name="M:nom.tam.fits.HeaderOrder.NAXISn(System.String)">
            <summary>Find the index for NAXISn keywords.</summary>
        </member>
        <member name="T:nom.tam.fits.ImageData">
            <summary>This class instantiates FITS primary HDU and IMAGE extension data.
            Essentially these data are a primitive multi-dimensional array.
            <p>
            Starting in version 0.9 of the nom.tam FITS library, this routine
            allows users to defer the reading of images if the FITS
            data is being read from a file.  An ImageTiler object is
            supplied which can return an arbitrary subset of the image
            as a one dimensional array.A call to the getData() method
            will still return a multi-dimensional array, but the
            image data will not be read until the user explicitly requests.
            it.</p>
            </summary>
        </member>
        <member name="P:nom.tam.fits.ImageData.TrueSize">
            <summary>Get the size in bytes of the data 
            </summary>
        </member>
        <member name="P:nom.tam.fits.ImageData.DataArray">
            <summary>Return the actual data.
            Note that this may return a null when
            the data is not readable.  It might be better
            to throw a FitsException, but this is
            a very commonly called method and we prefered
            not to change how users must invoke it.
            </summary>
        </member>
        <member name="P:nom.tam.fits.ImageData.Tiler">
            <summary>
            Returns the ImageTiler instance
            </summary>
        </member>
        <member name="F:nom.tam.fits.ImageData.byteSize">
            <summary>The size of the data 
            </summary>
        </member>
        <member name="F:nom.tam.fits.ImageData.dataArray">
            <summary>The actual array of data.  This
            is normally a multi-dimensional primitive array.
            It may be null until the getData() routine is
            invoked, or it may be filled by during the read
            call when a non-random access device is used.
            </summary>
        </member>
        <member name="T:nom.tam.fits.ImageData.ArrayDesc">
            <summary>This class describes an array</summary>
        </member>
        <member name="F:nom.tam.fits.ImageData.ArrayDesc.enclosingInstance">
            <summary>
            Instance of ImageData
            </summary>
        </member>
        <member name="F:nom.tam.fits.ImageData.ArrayDesc.dims">
            <summary>
            Stores the dimension of image data array
            </summary>
        </member>
        <member name="F:nom.tam.fits.ImageData.ArrayDesc.type">
            <summary>
            Stores the data tpe of image data instance
            </summary>
        </member>
        <member name="F:nom.tam.fits.ImageData.dataDescription">
            <summary>A description of what the data should look like 
            </summary>
        </member>
        <member name="T:nom.tam.fits.ImageData.ImageDataTiler">
            <summary>This inner class allows the ImageTiler
            to see if the user has read in the data.
            </summary>
        </member>
        <member name="F:nom.tam.fits.ImageData.tiler">
            <summary>The image tiler associated with this image.</summary>
        </member>
        <member name="M:nom.tam.fits.ImageData.#ctor(nom.tam.fits.Header)">
            <summary>Create an array from a header description.
            This is typically how data will be created when reading
            FITS data from a file where the header is read first.
            This creates an empty array.</summary>
            <param name="h">header to be used as a template.</param>
            <exception cref="T:nom.tam.fits.FitsException"> FitsException if there was a problem with the header description.</exception>
        </member>
        <member name="M:nom.tam.fits.ImageData.#ctor">
            <summary>Create the equivalent of a null data element.</summary>
        </member>
        <member name="M:nom.tam.fits.ImageData.#ctor(System.Object)">
            <summary>Create an ImageData object using the specified object to
            initialize the data array.
            </summary>
            <param name="x">The initial data array.  This should be a primitive
            array but this is not checked currently.
            </param>
        </member>
        <member name="M:nom.tam.fits.ImageData.FillHeader(nom.tam.fits.Header)">
            <summary>Fill header with keywords that describe image data.</summary>
            <param name="head">The FITS header</param>
            <exception cref="T:nom.tam.fits.FitsException"> FitsException if the object does not contain valid image data.</exception>
        </member>
        <member name="M:nom.tam.fits.ImageData.Read(nom.tam.util.ArrayDataIO)">
            <summary>
            Method to read data
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:nom.tam.fits.ImageData.Write(nom.tam.util.ArrayDataIO)">
            <summary>
            method to write data
            </summary>
            <param name="o"></param>
        </member>
        <member name="T:nom.tam.fits.ImageHDU">
            <summary>FITS image header/data unit.The ImageTiler class allows
            users to extract subimages from a FITS primary image or image extension.</summary>
        </member>
        <member name="P:nom.tam.fits.ImageHDU.CanBePrimary">
            <summary>Indicate that Images can appear at the beginning of a FITS dataset</summary>
        </member>
        <member name="P:nom.tam.fits.ImageHDU.PrimaryHDU">
            <summary>Change the Image from/to primary</summary>
        </member>
        <member name="P:nom.tam.fits.ImageHDU.Tiler">
            <summary>
            returns ImageTiler instance
            </summary>
        </member>
        <member name="M:nom.tam.fits.ImageHDU.#ctor(nom.tam.fits.Header,nom.tam.fits.Data)">
            <summary>Build an image HDU using the supplied data.</summary>
            <param name="obj">the data used to build the image.</param>
            <exception cref="T:nom.tam.fits.FitsException">If there was a problem with the data.</exception>
        </member>
        <member name="M:nom.tam.fits.ImageHDU.IsHeader(nom.tam.fits.Header)">
            <summary>Check that this HDU has a valid header for this type.</summary>
            <returns> <CODE>true</CODE> if this HDU has a valid header.</returns>
        </member>
        <member name="M:nom.tam.fits.ImageHDU.IsData(System.Object)">
            <summary>Check if this object can be described as a FITS image.</summary>
            <param name="o">The Object being tested.</param>
        </member>
        <member name="M:nom.tam.fits.ImageHDU.ManufactureData">
            <summary>Create a Data object to correspond to the header description.</summary>
            <returns> An unfilled Data object which can be used to read in the data for this HDU.</returns>
            <exception cref="!:"> FitsException if the image extension could not be created.</exception>
        </member>
        <member name="M:nom.tam.fits.ImageHDU.ManufactureHeader(nom.tam.fits.Data)">
            <summary>Create a  header that describes the given image data.</summary>
            <param name="o">The image to be described.</param>
            <exception cref="!:"> FitsException if the object does not contain valid image data.</exception>
        </member>
        <member name="M:nom.tam.fits.ImageHDU.Encapsulate(System.Object)">
            <summary>Encapsulate an object as an ImageHDU.</summary>
        </member>
        <member name="M:nom.tam.fits.ImageHDU.Info">
            <summary>Print out some information about this HDU.</summary>
        </member>
        <member name="T:nom.tam.fits.RandomGroupsData">
            <summary>This class instantiates FITS Random Groups data.
            Random groups are instantiated as a two-dimensional
            array of objects.  The first dimension of the array
            is the number of groups.  The second dimension is 2.
            The first object in every row is a one dimensional
            parameter array.  The second element is the n-dimensional
            data array.
            </summary>
        </member>
        <member name="P:nom.tam.fits.RandomGroupsData.TrueSize">
            <summary>Get the size of the actual data element. 
            </summary>
        </member>
        <member name="M:nom.tam.fits.RandomGroupsData.#ctor">
            <summary>Create the equivalent of a null data element.</summary>
        </member>
        <member name="M:nom.tam.fits.RandomGroupsData.#ctor(System.Array)">
            <summary>Create a RandomGroupsData object using the specified object to
            initialize the data array.
            </summary>
            <param name="x">The initial data array.  This should a two-d
            array of objects as described above.
            
            </param>
        </member>
        <member name="M:nom.tam.fits.RandomGroupsData.Read(nom.tam.util.ArrayDataIO)">
            <summary>Read the RandomGroupsData.</summary>
        </member>
        <member name="M:nom.tam.fits.RandomGroupsData.Write(nom.tam.util.ArrayDataIO)">
            <summary>Write the RandomGroupsData.</summary>
        </member>
        <member name="T:nom.tam.fits.RandomGroupsHDU">
            <summary>Random groups HDUs.  Note that the internal storage of random
            groups is a Object[ngroup][2] array.  The first element of
            each group is the parameter data from that group.  The second element
            is the data.  The parameters should be a one dimensional array
            of the primitive types byte, short, int, long, float or double.
            The second element is a n-dimensional array of the same type.
            When analyzing group data structure only the first group is examined,
            but for a valid FITS file all groups must have the same structure.
            </summary>
        </member>
        <member name="P:nom.tam.fits.RandomGroupsHDU.CanBePrimary">
            <summary>Indicate that a RandomGroupsHDU can come at the beginning of a FITS file.</summary>
        </member>
        <member name="P:nom.tam.fits.RandomGroupsHDU.PrimaryHDU">
            <summary>Move a RandomGroupsHDU to or from the beginning
            of a FITS file.  Note that the FITS standard only
            supports Random Groups data at the beginning
            of the file, but we allow it within Image extensions.
            </summary>
        </member>
        <member name="P:nom.tam.fits.RandomGroupsHDU.HasHeader">
            <summary>Check that this HDU has a valid header.</summary>
            <returns> <CODE>true</CODE> if this HDU has a valid header.</returns>
        </member>
        <member name="M:nom.tam.fits.RandomGroupsHDU.#ctor(nom.tam.fits.Header,nom.tam.fits.Data)">
            <summary>Create an HDU from the given header and data</summary>
        </member>
        <member name="M:nom.tam.fits.RandomGroupsHDU.ManufactureHeader(nom.tam.fits.Data)">
            <summary>Make a header point to the given object.</summary>
            <param name="odata">The random groups data the header should describe.</param>
        </member>
        <member name="M:nom.tam.fits.RandomGroupsHDU.IsHeader(nom.tam.fits.Header)">
            <summary>Is this a random groups header?</summary>
            <param name="myHeader">The header to be tested.</param>
        </member>
        <member name="M:nom.tam.fits.RandomGroupsHDU.IsData(System.Object)">
            <summary>Check if this data is compatible with Random Groups structure.
            Must be an Object[ngr][2] structure with both elements of each
            group having the same base type and the first element being
            a simple primitive array.  We do not check anything but
            the first row.</summary>
        </member>
        <member name="M:nom.tam.fits.RandomGroupsHDU.ManufactureData">
            <summary>Create a FITS Data object corresponding to this HDU header.</summary>
        </member>
        <member name="M:nom.tam.fits.RandomGroupsHDU.ManufactureData(nom.tam.fits.Header)">
            <summary>Create FITS data object corresponding to a given header.</summary>
        </member>
        <member name="M:nom.tam.fits.RandomGroupsHDU.Info">
            <summary>Display structural information about the current HDU.</summary>
        </member>
        <member name="T:nom.tam.fits.StreamedBinaryTableHDU">
            <summary>
            summary description for StreamedBinaryTableHDU.
            </summary>
        </member>
        <member name="M:nom.tam.fits.StreamedBinaryTableHDU.WriteOnePass(nom.tam.util.ArrayDataIO)">
            <summary>
              Writes this binary table in one pass.
              Requires foreknowledge of nRows and
              either no strings or truncated string output.
            </summary>
            <param name="s">The destination stream.</param>
        </member>
        <member name="M:nom.tam.fits.StreamedBinaryTableHDU.WriteThenFix(nom.tam.util.ArrayDataIO)">
            <summary>
              Writes this binary table in one pass,
              then seeks back to fix NAXIS2.  Requires
              s to be seekable and
              either no strings or truncated string output.
            </summary>
            <param name="s">The destination stream.</param>
        </member>
        <member name="M:nom.tam.fits.StreamedBinaryTableHDU.WriteHeapOutputWithTempHeapFile(nom.tam.util.ArrayDataIO)">
            <summary>
              Writes this binary table with heap temp file if necessary,
              then fixing nRows and PCOUNT in header,
              then if necessary copying heap file to destination stream.
            </summary>
            <param name="s">The destination stream.</param>
            steps:
            1) write the header to the main stream
               write the table to the main stream
               byterenderers write data to the heap if necessary
               byterenderers return heap positions and lengths if necessary
               these are returned as a byte sequence like any other data
               and are written to the table like any other data
            2) fix the header
            3) write the heap tempfile to the main stream
            what a pain
        </member>
        <member name="M:nom.tam.fits.StreamedBinaryTableHDU.WriteHeapOutputWithTempTableAndHeapFiles(nom.tam.util.ArrayDataIO)">
            <summary>
              Writes this binary table with data first going
              to a temp file (and heap file if necessary),
              then with header going to destination stream,
              then copying data from temp file to destination stream,
              then if necessary copying heap file to destination stream.
            </summary>
            <param name="s">The destination stream.</param>
            steps:
            1) write the table to a tempfile
               byterenderers write data to the heap if necessary
               byterenderers return heap positions and lengths if necessary
               these are returned as a byte sequence like any other data
               and are written to the table like any other data
            2) fix the header
               write the header to the main stream
            3) write the table tempfile to the main stream
            4) write the heap tempfile to the main stream
            what a pain
        </member>
        <member name="M:nom.tam.fits.StreamedBinaryTableHDU.WritePadOutput(nom.tam.util.ArrayDataIO)">
            <summary>
              Writes this binary table with data first going
              to a temp file (and heap file if necessary),
              then with header going to destination stream,
              then merging heap with table data if necessary
              and copying these to destination stream.
            </summary>
            <param name="s">The destination stream.</param>
            steps:
            1) write the table to a tempfile
               byterenderers write data to the heap if necessary
               byterenderers return heap positions and lengths if necessary
               these are returned as a byte sequence like any other data
               and are written to the table like any other data
            2) fix the header
               write the header to the main stream
            3) write the table tempfile to the main stream, merging heap if necessary
            what a pain
        </member>
        <member name="T:nom.tam.fits.TableData">
            <summary>This class allows FITS binary and ASCII tables to be accessed via a common interface.</summary>
        </member>
        <member name="T:nom.tam.fits.TableHDU">
            <summary>This class allows FITS binary and ASCII tables to
            be accessed via a common interface.
            </summary>
        </member>
        <member name="P:nom.tam.fits.TableHDU.NCols">
            <summary>Get the number of columns for this table</summary>
            <returns> The number of columns in the table.</returns>
        </member>
        <member name="P:nom.tam.fits.TableHDU.NRows">
            <summary>Get/set the number of rows for this table</summary>
            <returns> The number of rows in the table.</returns>
        </member>
        <member name="M:nom.tam.fits.TableHDU.GetColumnName(System.Int32)">
            <summary>Get the name of a column in the table.</summary>
            <param name="index">The 0-based column index.</param>
            <returns> The column name.</returns>
            <exception cref="!:"> FitsException if an invalid index was requested.</exception>
        </member>
        <member name="M:nom.tam.fits.TableHDU.GetColumnFormat(System.Int32)">
            <summary>Get the FITS type of a column in the table.</summary>
            <returns> The FITS type.</returns>
            <exception cref="!:"> FitsException if an invalid index was requested.</exception>
        </member>
        <member name="M:nom.tam.fits.TableHDU.DeleteRows(System.Int32)">
            <summary>
            Remove all rows from the table starting at some specific index from the table.
            Inspired by a routine by R. Mathar but re-implemented using the DataTable and
            changes to AsciiTable so that it can be done easily for both Binary and ASCII tables.
            </summary>
            <param name="row">The (0-based) index of the first row to be deleted.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:nom.tam.fits.TableHDU.DeleteRows(System.Int32,System.Int32)" -->
        <member name="M:nom.tam.fits.TableHDU.DeleteColumnsIndexOne(System.Int32,System.Int32)">
            <summary>Delete a set of columns from a table.</summary>
        </member>
        <member name="M:nom.tam.fits.TableHDU.DeleteColumnsIndexZero(System.Int32,System.Int32)">
            <summary>Delete a set of columns from a table.</summary>
        </member>
        <member name="M:nom.tam.fits.TableHDU.DeleteColumnsIndexOne(System.Int32,System.Int32,System.String[])">
            <summary>Delete a set of columns from a table.</summary>
            <param name="column">The one-indexed start column.</param>
            <param name="len">The number of columns to delete.</param>
            <param name="fields">Stems for the header fields to be removed for the table.</param>
        </member>
        <member name="M:nom.tam.fits.TableHDU.DeleteColumnsIndexZero(System.Int32,System.Int32,System.String[])">
            <summary>Delete a set of columns from a table.</summary>
            <param name="column">The zero-indexed start column.</param>
            <param name="len">The number of columns to delete.</param>
            <param name="fields">Stems for the header fields to be removed for the table.</param>
        </member>
        <member name="P:nom.tam.fits.TableHDU.ColumnKeyStems">
            <summary>
            Get the stems of the keywords that are associated 
            with table columns. Users can supplement this 
            with their own and call the appropriate deleteColumns fields.
            </summary>
        </member>
        <member name="T:nom.tam.fits.TruncatedFileException">
            <summary>This exception is thrown when an EOF is detected in the middle
            of an HDU.
            </summary>
        </member>
        <member name="M:nom.tam.fits.TruncatedFileException.#ctor">
            <summary>
            Constructor taking no arguments
            </summary>
        </member>
        <member name="M:nom.tam.fits.TruncatedFileException.#ctor(System.String)">
            <summary>
            Constructor taking string argument
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:nom.tam.fits.UndefinedData">
            <summary>This class provides a simple holder for data which is
            not handled by other classes.
            </summary>
        </member>
        <member name="P:nom.tam.fits.UndefinedData.TrueSize">
            <summary>Get the size in bytes of the data</summary>
        </member>
        <member name="P:nom.tam.fits.UndefinedData.DataArray">
            <summary>Return the actual data.
            Note that this may return a null when
            the data is not readable.  It might be better
            to throw a FitsException, but this is
            a very commonly called method and we prefered
            not to change how users must invoke it.
            </summary>
        </member>
        <member name="F:nom.tam.fits.UndefinedData.byteSize">
            <summary>The size of the data 
            </summary>
        </member>
        <member name="M:nom.tam.fits.UndefinedData.#ctor(nom.tam.fits.Header)">
            <summary>
            Create an UndefinedData object using the specified header.
            </summary>
            <param name="h"></param>
        </member>
        <member name="M:nom.tam.fits.UndefinedData.#ctor(System.Object)">
            <summary>Create an UndefinedData object using the specified object.</summary>
        </member>
        <member name="M:nom.tam.fits.UndefinedData.FillHeader(nom.tam.fits.Header)">
            <summary>Fill header with keywords that describe data.
            </summary>
            <param name="head">The FITS header
            
            </param>
        </member>
        <member name="M:nom.tam.fits.UndefinedData.Read(nom.tam.util.ArrayDataIO)">
            <summary>
            Method to read the ArrayDataIO
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:nom.tam.fits.UndefinedData.Write(nom.tam.util.ArrayDataIO)">
            <summary>
            Method Write ArrayDataIO
            </summary>
            <param name="o"></param>
        </member>
        <member name="T:nom.tam.fits.UndefinedHDU">
            <summary>Holder for unknown data types. 
            </summary>
        </member>
        <member name="M:nom.tam.fits.UndefinedHDU.#ctor(nom.tam.fits.Header,nom.tam.fits.Data)">
            <summary>Build an image HDU using the supplied data.</summary>
            <param name="obj">the data used to build the image.</param>
            <exception cref="!:"> FitsException if there was a problem with the data.</exception>
        </member>
        <member name="M:nom.tam.fits.UndefinedHDU.IsHeader(nom.tam.fits.Header)">
            <summary>Check if we can find the length of the data for this header.</summary>
            <returns><CODE>true</CODE> if this HDU has a valid header.</returns>
        </member>
        <member name="M:nom.tam.fits.UndefinedHDU.IsData(System.Object)">
            <summary>Check if we can use the following object as
            in an Undefined FITS block.  We allow this
            so long as computeSize can get a size.  Note
            that computeSize may be wrong!
            </summary>
            <param name="o">The Object being tested.</param>
        </member>
        <member name="M:nom.tam.fits.UndefinedHDU.ManufactureData">
            <summary>Create a Data object to correspond to the header description.</summary>
            <returns> An unfilled Data object which can be used to read
            in the data for this HDU.
            </returns>
            <exception cref="!:"> FitsException if the image extension could not be created.</exception>
        </member>
        <member name="M:nom.tam.fits.UndefinedHDU.ManufactureData(nom.tam.fits.Header)">
            <summary>
            Create a UndefinedData object to correspond to the header description.
            </summary>
            <param name="hdr"></param>
            <returns></returns>
        </member>
        <member name="M:nom.tam.fits.UndefinedHDU.ManufactureHeader(nom.tam.fits.Data)">
            <summary>Create a  header that describes the given
            image data.
            </summary>
            <param name="o">The image to be described.
            </param>
            <exception cref="!:"> FitsException if the object does not contain
            valid image data.
            
            </exception>
        </member>
        <member name="M:nom.tam.fits.UndefinedHDU.Encapsulate(System.Object)">
            <summary>Encapsulate an object as an ImageHDU.</summary>
        </member>
        <member name="M:nom.tam.fits.UndefinedHDU.Info">
            <summary>Print out some information about this HDU.</summary>
        </member>
        <member name="T:nom.tam.image.ImageTiler">
            <summary>The ImageTiler class allows users to extract subimages from a FITS primary image 
            or image extension.
            This class provides a subset of an N-dimensional image.
            Modified May 2, 2000 by T. McGlynn to permit
            tiles that go off the edge of the image.
            </summary>
        </member>
        <member name="P:nom.tam.image.ImageTiler.MemoryImage">
            <summary>See if we can get the image data from memory.
            This may be overriden by other classes, notably
            in nom.tam.fits.ImageData.</summary>
        </member>
        <member name="P:nom.tam.image.ImageTiler.CompleteImage">
            <summary>Read the entire image into a multidimensional array.</summary>
        </member>
        <member name="M:nom.tam.image.ImageTiler.#ctor(nom.tam.util.RandomAccess,System.Int64,System.Int32[],System.Type)">
            <summary>Create a tiler.</summary>
            <param name="f">The random access device from which image data may be read.
            This may be null if the tile information is available from memory.</param>
            <param name="fileOffset">The file offset within the RandomAccess device at which
            the data begins.</param>
            <param name="dims">The actual dimensions of the image.</param>
            <param name="base_Renamed">base class (should be a primitive type) of the image.</param>
        </member>
        <member name="M:nom.tam.image.ImageTiler.GetTile(System.Int32[],System.Int32[])">
            <summary>Get a subset of the image.  An image tile is returned
            as a one-dimensional array although the image will
            normally be multi-dimensional.</summary>
            <param name="corners">starting corner (using 0 as the start) for the image.</param>
            <param name="lenghts">length requested in each dimension.</param>
        </member>
        <member name="M:nom.tam.image.ImageTiler.GetTile(System.Array,System.Int32[],System.Int32[])">
            <summary>Get a tile, filling in a prespecified array.
            This version does not check that the user hase
            entered a valid set of corner and length arrays.
            ensure that out matches the
            length implied by the lengths array.</summary>
            <param name="outArray">The output tile array.  A one-dimensional
            array. Data not within the valid limits of the image will
            be left unchanged.  The length of this array should be the
            product of lengths.</param>
            <param name="corners">The corners of the tile.</param>
            <param name="lengths">The dimensions of the tile.</param>
        </member>
        <member name="M:nom.tam.image.ImageTiler.FillTile(System.Array,System.Array,System.Int32[],System.Int32[],System.Int32[])">
            <summary>Fill the subset.</summary>
            <param name="data">The memory-resident data image.
            This may be null if the image is to be read from a file.  This should
            be a multi-dimensional primitive array.</param>
            <param name="o">The tile to be filled.  This is a simple primitive array.</param>
            <param name="dims">The dimensions of the full image.</param>
            <param name="corners">The indices of the corner of the image.</param>
            <param name="lengths">The dimensions of the subset.</param>
        </member>
        <member name="M:nom.tam.image.ImageTiler.FillMemData(System.Array,System.Int32[],System.Int32,System.Array,System.Int32,System.Int32)">
            <summary>Fill a single segment from memory.
            This routine is called recursively to handle multi-dimensional
            arrays.  E.g., if data is three-dimensional, this will
            recurse two levels until we get a call with a single dimensional
            datum.  At that point the appropriate data will be copied
            into the output.</summary>
            <param name="data">The in-memory image data.</param>
            <param name="posits">The current position for which data is requested.</param>
            <param name="length">The size of the segments.</param>
            <param name="output">The output tile.</param>
            <param name="outputOffset">The current offset into the output tile.</param>
            <param name="dim">The current dimension being</param>
        </member>
        <member name="M:nom.tam.image.ImageTiler.FillFileData(System.Array,System.Int32,System.Int32,System.Int32)">
            <summary>File a tile segment from a file.</summary>
            <param name="output">The output tile.</param>
            <param name="delta">The offset from the beginning of the image in bytes.</param>
            <param name="outputOffset">The index into the output array.</param>
            <param name="segment">The number of elements to be read for this segment.</param>
        </member>
        <member name="M:nom.tam.image.ImageTiler.IncrementPosition(System.Int32[],System.Int32[],System.Int32[])">
            <summary>Increment the offset within the position array.
            Note that we never look at the last index since
            we copy data a block at a time and not byte by byte.</summary>
            <param name="start">starting corner values.</param>
            <param name="current">current offsets.</param>
            <param name="lengths">The desired dimensions of the subset.</param>
        </member>
        <member name="M:nom.tam.image.ImageTiler.GetOffset(System.Int32[],System.Int32[])">
            <summary>Get the offset of a given position.</summary>
            <param name="dims"> The dimensions of the array.</param>
            <param name="pos">  The index requested.</param>
        </member>
        <member name="T:nom.tam.util.ActualBufferedStream">
            <summary>
             The comparison between inline buffering versus System.IO.BufferedStream versus
              unbuffered output, and System.IO.BufferedStream shows no improvement
              whatsoever over unbuffered output, whereas hand-implemented buffered
              output with the same buffer size settings show drastic improvement.
              Hence this class.
            </summary>
        </member>
        <member name="T:nom.tam.util.AdapterStream">
            <summary>
            When writing new Streams, I'm tired of having to forward most of the methods
            to the underlying Stream.  So this is the default behavior in this class, and
            subclasses are free to override any methods they see fit.
            </summary>
        </member>
        <member name="T:nom.tam.util.ArrayDataIO">
            <summary>summary description for ArrayDataIO.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:nom.tam.util.ArrayDataIO.ReadArray(System.Object)" -->
        <member name="M:nom.tam.util.ArrayDataIO.Read(System.Byte[])">
            <summary>
            Read a complete primitive array
            </summary>
            <param name="buf"></param>
            <returns></returns>
        </member>
        <member name="M:nom.tam.util.ArrayDataIO.Read(System.SByte[],System.Int32,System.Int32)">
            <summary>
             Read a segment of a primitive array.
            </summary>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:nom.tam.util.ArrayDataIO.WriteArray(System.Object)" -->
        <member name="M:nom.tam.util.ArrayDataIO.Write(System.String[])">
            <summary>
            Write an array of Strings 
            </summary>
            <param name="buf"></param>
        </member>
        <member name="M:nom.tam.util.ArrayDataIO.Write(System.SByte[],System.Int32,System.Int32)">
            <summary>
            Write a segment of a primitive array.
            </summary>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="size"></param>
        </member>
        <member name="M:nom.tam.util.ArrayDataIO.Write(System.String[],System.Int32,System.Int32)">
            <summary>
             Write some of an array of Strings 
            </summary>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="size"></param>
        </member>
        <member name="T:nom.tam.util.ArrayFuncs">
            <summary>This is a package of static functions which perform
            computations on arrays.  Generally these routines attempt
            to complete without throwing errors by ignoring data
            they cannot understand.
            </summary>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.CountDimensions(System.Object)">
            <summary>
            Method to count the dimensions of array
            </summary>
            <param name="o"></param>
            <returns>returns dimension of array</returns>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.IsArrayOfArrays(System.Object)">
            <summary>
            Checks whether the object is a type of Array of Arrays
            </summary>
            <param name="o"></param>
            <returns>Returns boolean depending upon the Arra type</returns>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.ComputeSize(System.Object)">
            <summary>Compute the size of an object.  Note that this only handles
            arrays or scalars of the primitive objects and Strings.  It
            returns 0 for any object array element it does not understand.</summary>
            <param name="o">The object whose size is desired.</param>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.CountElements(System.Object)">
            <summary>Count the number of elements in an array</summary>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.DeepClone(System.Object)">
            <summary>Try to create a deep clone of an Array or a standard clone of a scalar.
            The object may comprise arrays of any primitive type or any Object type which
            implements Cloneable.  However, if the Object is some kind of collection,
            e.g., a Vector then only a shallow copy of that object is made.  I.e., deep
            refers only to arrays.
            </summary>
            <param name="o">The object to be copied.</param>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.GenericClone(System.Object)">
            <summary>Clone an Object if possible.
            *
            This method returns an Object which is a clone of the
            input object.  It checks if the method implements the
            Cloneable interface and then uses reflection to invoke
            the clone method.  This can't be done directly since
            as far as the compiler is concerned the clone method for
            Object is protected and someone could implement Cloneable but
            leave the clone method protected.  The cloning can fail in a
            variety of ways which are trapped so that it returns null instead.
            This method will generally create a shallow clone.  If you
            wish a deep copy of an array the method DeepClone should be used.
            *
            </summary>
            <param name="o">The object to be cloned.
            
            </param>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.GetDimensions(System.Object)">
            <summary>Find the dimensions of an object.
            *
            This method returns an integer array with the dimensions
            of the object o which should usually be an array.
            *
            It returns an array of dimension 0 for scalar objects
            and it returns -1 for dimension which have not been allocated,
            e.g., int[][][] x = new int[100][][]; should return [100,-1,-1].
            *
            </summary>
            <param name="o">The object to get the dimensions of.</param>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.GetBaseClass(System.Object)">
            <summary>This routine returns the base class of an object. This is just
            the class of the object for non-arrays.</summary>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.GetBaseType(System.Object)">
            <summary>This routine returns the base class of an object with the dimension indication
            in form of brackets and/or commas. This is just
            the type of the object for non-arrays.</summary>
            TODO: This routine is implemented to get type of the object including all the dimensions with it.
            If object 'x' is 2D Array type with elements filled in of type byte,
            then x.GetType will return only System.Array[], but this routine will give System.Byte[][].
            One can remove this method in future, if similar functionality provided by any library routine itself.
            "This routine is only used in ArrayEquals."
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.GetBaseLength(System.Object)">
            <summary>This routine returns the size of the base element of an array.</summary>
            <param name="o">The array object whose base length is desired.</param>
            <returns>the size of the object in bytes, 0 if null, or -1 if not a primitive array.
            </returns>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.ArrayDescription(System.Object)">
            <summary>Generate a description of an array (presumed rectangular).</summary>
            <param name="o">The array to be described.</param>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.Flatten(System.Object)">
            <summary>Given an array of arbitrary dimensionality return
            the array flattened into a single dimension.</summary>
            <param name="input">The input array.</param>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.DoFlatten(System.Object,System.Array,System.Int32)">
            <summary>This routine does the actually flattening of multi-dimensional arrays.</summary>
            <param name="input"> The input array to be flattened.</param>
            <param name="output">The flattened array.</param>
            <param name="offset">The current offset within the output array.</param>
            <returns>The number of elements within the array.</returns>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.Curl(System.Array,System.Int32[])">
            <summary>Curl an input array up into a multi-dimensional array.</summary>
            <param name="input">The one dimensional array to be curled.</param>
            <param name="dimens">The desired dimensions</param>
            <returns>The curled array.</returns>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.NextIndex(System.Int32[],System.Int32[])">
            <summary>
            Check whether next index
            </summary>
            <param name="index"></param>
            <param name="dims"></param>
            <returns>returns boolean value depending upon the values in array</returns>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.NextIndex(System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Checks whether next index
            </summary>
            <param name="index"></param>
            <param name="starts"></param>
            <param name="dims"></param>
            <returns></returns>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.NewInstance(System.Type,System.Int32)">
            <summary>Allocate an array dynamically. The Array.NewInstance method
            does not throw an error.</summary>
            <param name="cl"> The class of the array.</param>
            <param name="dim"> The dimension of the array.</param>
            <returns> The allocated array.</returns>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.NewInstance(System.Type,System.Int32[])">
            <summary>Allocate an array dynamically. The Array.NewInstance method
            does not throw an error.</summary>
            <param name="cl"> The class of the array.</param>
            <param name="dims">The dimensions of the array.</param>
            <returns>The allocated array.</returns>
            <throws>An OutOfMemoryError if insufficient space is available.</throws>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.NewInstance(System.Type,System.Int32[],System.Int32)">
            <summary>allocate an arrayof passed dimensions dynamically. The Array.NewInstance method
            does not throw an error
            </summary>
            <param name="cl">The class of the array.</param>
            <param name="dims">The dimensions of the array.</param>
            <param name="dim">The index in the array</param>
            <returns>The allocated array.</returns>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.ArrayEquals(System.Object,System.Object)">
            <summary>
            Are two objects equal?  Arrays have the standard object equals
            method which only returns true if the two object are the same.
            This method returns true if every element of the arrays match.
            The inputs may be of any dimensionality.  The dimensionality
            and dimensions of the arrays must match as well as any elements.
            If the elements are non-primitive. non-array objects, then the 
            equals method is called for each element.
            If both elements are multi-dimensional arrays, then
            the method recurses.
            </summary>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.ArrayEquals(System.Object,System.Object,System.Double,System.Double)">
            <summary>
            Are two objects equal?  Arrays have the standard object equals
            method which only returns true if the two object are the same.
            This method returns true if every element of the arrays match.
            The inputs may be of any dimensionality.  The dimensionality
            and dimensions of the arrays must match as well as any elements.
            If the elements are non-primitive. non-array objects, then the 
            equals method is called for each element.
            If both elements are multi-dimensional arrays, then
            the method recurses.
              </summary>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.DoubleArrayEquals(System.Double[],System.Double[],System.Double)">
            <summary> Compare two double arrays using a given tolerance.</summary>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.FloatArrayEquals(System.Single[],System.Single[],System.Single)">
            <summary> Compare two float arrays using a given tolerance.</summary>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.ConvertArray(System.Object,System.Type)">
            <summary>Convert an array to a specified type. This method supports conversions
            only among the primitive numeric types.</summary>
            <param name="array">A possibly multidimensional array to be converted.</param>
            <param name="newType">The desired output type.  This should be one of the
                           class descriptors for primitive numeric data, e.g., double.type.</param>
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.MimicArray(System.Object,System.Type)">
            <summary>Create an array of a type given by new type with
            the dimensionality given in array.</summary>
            <param name="array">A possibly multidimensional array to be converted.</param>
            <param name="newType">The desired output type.  This should be one of the
            class descriptors for primitive numeric data, e.g., double.type.</param>		
        </member>
        <member name="M:nom.tam.util.ArrayFuncs.CopyArray(System.Object,System.Object)">
            <summary>Copy one array into another.
            This function copies the contents of one array
            into a previously allocated array.
            The arrays must agree in type and size.
            </summary>
            <param name="original">The array to be copied.
            </param>
            <param name="copy">    The array to be copied into.  This
            array must already be fully allocated.
            
            </param>
        </member>
        <member name="T:nom.tam.util.BufferedDataStream">
            <summary>
            summary description for BufferedDataStream.
            </summary>
        </member>
        <member name="M:nom.tam.util.BufferedDataStream.#ctor(System.IO.Stream)">
            <summary>
            Constructor initializing stream
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:nom.tam.util.BufferedDataStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Constructor initializing stream of given buffer length
            </summary>
            <param name="s"></param>
            <param name="bufLength"></param>
        </member>
        <member name="M:nom.tam.util.BufferedDataStream.ReadArray(System.Object)">
            <summary>Read an object.  An EOF will be signaled if the
            object cannot be fully read.  The getPrimitiveArrayCount()
            method may then be used to get a minimum number of bytes read.
            </summary>
            <param name="o"> The object to be read.  This object should
            be a primitive (possibly multi-dimensional) array.
            
            </param>
            <returns>s  The number of bytes read.
            
            </returns>
        </member>
        <member name="M:nom.tam.util.BufferedDataStream.PrimitiveArrayRecurse(System.Object)">
            <summary>Read recursively over a multi-dimensional array.</summary>
            <returns> The number of bytes read.</returns>
        </member>
        <member name="M:nom.tam.util.BufferedDataStream.WriteArray(System.Object)">
            <summary>This routine provides efficient writing of arrays of any primitive type.
            The String class is also handled but it is an error to invoke this
            method with an object that is not an array of these types.  If the
            array is multidimensional, then it calls itself recursively to write
            the entire array.  Strings are written using the standard
            1 byte format (i.e., as in writeBytes).
            *
            If the array is an array of objects, then writePrimitiveArray will
            be called for each element of the array.
            *
            </summary>
            <param name="o"> The object to be written.  It must be an array of a primitive
            type, Object, or String.</param>
        </member>
        <member name="M:nom.tam.util.BufferedDataStream.Flush">
            <summary>
            Flushes/Clears the output stream
            </summary>
        </member>
        <member name="M:nom.tam.util.BufferedDataStream.Close">
            <summary>
            Closed the input/output buffer streams
            </summary>
        </member>
        <member name="T:nom.tam.util.BufferedFile">
            <summary>summary description for BufferedFile.</summary>
        </member>
        <member name="M:nom.tam.util.BufferedFile.#ctor(System.String)">
            <summary>Create a read-only buffered file</summary>
        </member>
        <member name="M:nom.tam.util.BufferedFile.#ctor(System.String,System.IO.FileAccess,System.IO.FileShare)">
            <summary>Create a buffered file with the given mode.</summary>
            <param name="filename">The file to be accessed.</param>
            <param name="access">Read/write</param>
        </member>
        <member name="M:nom.tam.util.BufferedFile.#ctor(System.IO.FileInfo)">
            <summary> Create a buffered file from a File descriptor.</summary>
        </member>
        <member name="M:nom.tam.util.BufferedFile.#ctor(System.IO.FileInfo,System.IO.FileAccess,System.IO.FileShare)">
            <summary> Create a buffered file from a File descriptor.</summary>
        </member>
        <member name="M:nom.tam.util.BufferedFile.#ctor(System.String,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
            <summary>
             Create a buffered file from a FileAccess and FileShare descriptor ,Bufer size
            </summary>
            <param name="filename"></param>
            <param name="access"></param>
            <param name="share"></param>
            <param name="bufferSize"></param>
        </member>
        <member name="M:nom.tam.util.BufferedFile.#ctor(System.IO.FileInfo,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
            <summary>Create a buffered file with the given mode and a specified
            buffer size.
            </summary>
            <param name="filename">The file to be accessed.</param>
            <param name="mode">Read/write</param>
            <param name="buffer">The buffer size to be used. This should be
            substantially larger than 100 bytes and
            defaults to 32768 bytes in the other
            constructors.</param>
        </member>
        <member name="P:nom.tam.util.BufferedFile.FilePointer">
            <summary>Get the current position in the stream</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:nom.tam.util.ByteFormatter" -->
        <member name="M:nom.tam.util.ByteFormatter.#ctor">
            <summary>
            Initialize tbuf1,tbuf2,truncationFill
            </summary>
        </member>
        <member name="P:nom.tam.util.ByteFormatter.TruncateOnOverflow">
            <summary>Set the truncation behavior.
            If set to true (the default) then do not
            exceed the requested length.  If a number cannot
            be sensibly formatted, the truncation fill character
            may be inserted.</summary>
        </member>
        <member name="P:nom.tam.util.ByteFormatter.TruncationThrow">
            <summary>Should truncations cause a truncation overflow?</summary>
        </member>
        <member name="P:nom.tam.util.ByteFormatter.TruncationFill">
            <summary>Set the truncation fill character.The character to be used in subsequent truncations.</summary>
        </member>
        <member name="P:nom.tam.util.ByteFormatter.Align">
            <summary>Set the alignment flag.</summary>
        </member>
        <member name="F:nom.tam.util.ByteFormatter.tbuf1">
            <summary>Internal buffers used in formatting fields</summary>
        </member>
        <member name="F:nom.tam.util.ByteFormatter.truncateOnOverflow">
            <summary>Should we truncate overflows or just run over limit</summary>
        </member>
        <member name="F:nom.tam.util.ByteFormatter.truncationFill">
            <summary>What do we use to fill when we cannot print the number?</summary>
        </member>
        <member name="F:nom.tam.util.ByteFormatter.truncationThrow">
            <summary>Throw exception on truncations</summary>
        </member>
        <member name="F:nom.tam.util.ByteFormatter.align">
            <summary>Should we right align?</summary>
        </member>
        <member name="F:nom.tam.util.ByteFormatter.simpleMin">
            <summary>Minimum magnitude to print in non-scientific notation.</summary>
        </member>
        <member name="F:nom.tam.util.ByteFormatter.simpleMax">
            <summary>Maximum magnitude to print in non-scientific notation.</summary>
        </member>
        <member name="F:nom.tam.util.ByteFormatter.tenpow">
            <summary>Powers of 10.  We overextend on both sides.
            These should perhaps be tabulated rather than
            computed though it may be faster to calculate
            them than to read in the extra bytes in the class file.
            </summary>
        </member>
        <member name="F:nom.tam.util.ByteFormatter.zeropow">
            <summary>What index of tenpow is 10^0</summary>
        </member>
        <member name="F:nom.tam.util.ByteFormatter.digits">
            <summary>Digits.  We could handle other bases
            by extending or truncating this list and changing
            the division by 10 (and it's factors) at various
            locations.
            </summary>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.setSimpleRange(System.Double,System.Double)">
            <summary>Set the range of real numbers that will be formatted in
            non-scientific notation, i.e., .00001 rather than 1.0e-5.
            The sign of the number is ignored.
            </summary>
            <param name="min"> The minimum value for non-scientific notation.</param>
            <param name="max"> The maximum value for non-scientific notation.</param>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.format(System.Int32,System.Byte[])">
            <summary>Format an int into an array.</summary>
            <param name="val">The int to be formatted.</param>
            <param name="array">The array in which to place the result.</param>
            <returns>The number of characters used.</returns>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.format(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Format an int into an existing array.</summary>
            <param name="val">Integer to be formatted</param>
            <param name="buf">Buffer in which result is to be stored</param>
            <param name="off">Offset within buffer</param>
            <param name="len">Maximum length of integer</param>
            <returns>offset of next unused character in input buffer.</returns>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.format(System.Int64,System.Byte[])">
            <summary>Format a long into an array.</summary>
            <param name="val">The long to be formatted.</param>
            <param name="array">The array in which to place the result.</param>
            <returns>  The number of characters used.</returns>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.format(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>Format a long into an existing array.</summary>
            <param name="val">    Long to be formatted</param>
            <param name="buf">    Buffer in which result is to be stored</param>
            <param name="off">    Offset within buffer</param>
            <param name="len">    Maximum length of integer</param>
            <returns> offset of next unused character in input buffer.</returns>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.format(System.Boolean,System.Byte[])">
            <summary>Format a boolean into an existing array.</summary>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.format(System.Boolean,System.Byte[],System.Int32,System.Int32)">
            <summary>Format a boolean into an existing array</summary>
            <param name="val">The boolean to be formatted</param>
            <param name="array">The buffer in which to format the data.</param>
            <param name="off">The starting offset within the buffer.</param>
            <param name="len">The maximum number of characters to use in formatting the number.</param>
            <returns>Offset of next available character in buffer.</returns>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.format(System.String,System.Byte[])">
            <summary>Insert a string at the beginning of an array</summary>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.format(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>Insert a String into an existing character array.
            If the String is longer than len, then only the
            the initial len characters will be inserted.
            </summary>
            <param name="val">The string to be inserted.  A null string will insert len spaces.</param>
            <param name="array">The buffer in which to insert the string.</param>
            <param name="off">The starting offset to insert the string.</param>
            <param name="len">The maximum number of characters to insert.</param>
            <returns>Offset of next available character in buffer.</returns>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.format(System.Single,System.Byte[])">
            <summary>Format a float into an array.</summary>
            <param name="val">The float to be formatted.</param>
            <param name="array">The array in which to place the result.</param>
            <returns>The number of characters used.</returns>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.format(System.Single,System.Byte[],System.Int32,System.Int32)">
            <summary>Format a float into an existing byteacter array.
            <p>
            This is hard to do exactly right...  The JDK code does
            stuff with rational arithmetic and so forth.
            We use a much simpler algorithm which may give
            an answer off in the lowest order bit.
            Since this is pure Java, it should still be consistent
            from machine to machine.
            <p>
            Recall that the binary representation of
            the float is of the form <tt>d = 0.bbbbbbbb x 2<sup>n</sup></tt>
            where there are up to 24 binary digits in the binary
            fraction (including the assumed leading 1 bit
            for normalized numbers).
            We find a value m such that <tt>10<sup>m</sup> d</tt> is between 
            <tt>2<sup>24</sup></tt> and <tt>>2<sup>32</sup></tt>.
            This product will be exactly convertible to an int
            with no loss of precision.  Getting the
            decimal representation for that is trivial (see formatInteger).
            This is a decimal mantissa and we have an exponent (<tt>-m</tt>).
            All we have to do is manipulate the decimal point
            to where we want to see it.  Errors can
            arise due to roundoff in the scaling multiplication, but
            should be very small.
            </p></p>
            </summary>
            <param name="val">Float to be formatted</param>
            <param name="buf">Buffer in which result is to be stored</param>
            <param name="off">Offset within buffer</param>
            <param name="len">Maximum length of field</param>
            <returns>Offset of next character in buffer.</returns>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.format(System.Double,System.Byte[])">
            <summary>Format a double into an array.</summary>
            <param name="val">The double to be formatted.</param>
            <param name="array">The array in which to place the result.</param>
            <returns>The number of characters used.</returns>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.format(System.Double,System.Byte[],System.Int32,System.Int32)">
            <summary>Format a double into an existing character array.
            <p>
            This is hard to do exactly right...  The JDK code does
            stuff with rational arithmetic and so forth.
            We use a much simpler algorithm which may give
            an answer off in the lowest order bit.
            Since this is pure Java, it should still be consistent
            from machine to machine.
            <p>
            Recall that the binary representation of
            the double is of the form <tt>d = 0.bbbbbbbb x 2<sup>n</sup></tt>
            where there are up to 53 binary digits in the binary
            fraction (including the assumed leading 1 bit
            for normalized numbers).
            We find a value m such that <tt>10<sup>m</sup> d</tt> is between 
            <tt>2<sup>53</sup></tt> and <tt>>2<sup>63</sup></tt>.
            This product will be exactly convertible to a long
            with no loss of precision.  Getting the
            decimal representation for that is trivial (see formatLong).
            This is a decimal mantissa and we have an exponent (<tt>-m</tt>).
            All we have to do is manipulate the decimal point
            to where we want to see it.  Errors can
            arise due to roundoff in the scaling multiplication, but
            should be no more than a single bit.
            </p></p>
            </summary>
            <param name="val">    Double to be formatted
            </param>
            <param name="buf">    Buffer in which result is to be stored
            </param>
            <param name="off">    Offset within buffer
            </param>
            <param name="len">    Maximum length of integer
            </param>
            <returns> offset of next unused character in input buffer.
            
            </returns>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.combineReal(System.Double,System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>This method formats a double given a decimal mantissa and exponent information.</summary>
            <param name="val">  The original number</param>
            <param name="buf">  Output buffer</param>
            <param name="off">  Offset into buffer</param>
            <param name="len">  Maximum number of characters to use in buffer.</param>
            <param name="mant"> A decimal mantissa for the number.</param>
            <param name="lmant">The number of characters in the mantissa</param>
            <param name="shift">The exponent of the power of 10 that we shifted val to get the given mantissa.</param>
            <returns>      Offset of next available character in buffer.</returns>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.mantissa(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Byte[],System.Int32,System.Int32)">
            <summary>Write the mantissa of the number.  This method addresses
            the subtleties involved in rounding numbers.
            </summary>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.truncationFiller(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill the buffer with truncation characters.  After filling
            the buffer, a TruncationException will be thrown if the
            appropriate flag is set.
            </summary>
            <exception cref="T:nom.tam.util.TruncationException"> </exception>"
        </member>
        <member name="M:nom.tam.util.ByteFormatter.alignFill(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill the buffer with blanks to align a field.</summary>
        </member>
        <member name="M:nom.tam.util.ByteFormatter.#cctor">
            <summary>
            Static Initializer for byte formatter
            </summary>
        </member>
        <member name="T:nom.tam.util.ByteParser">
            <summary>This class provides routines
            for efficient parsing of data stored in a byte array.
            This routine is optimized (in theory at least!) for efficiency
            rather than accuracy.  The values read in for doubles or floats
            may differ in the last bit or so from the standard input
            utilities, especially in the case where a float is specified
            as a very long string of digits (substantially longer than
            the precision of the type).
            <p>
            The get methods generally are available with or without a length
            parameter specified.  When a length parameter is specified only
            the bytes with the specified range from the current offset will
            be search for the number.  If no length is specified, the entire
            buffer from the current offset will be searched.
            <p>
            The getString method returns a string with leading and trailing
            white space left intact.  For all other get calls, leading
            white space is ignored.  If fillFields is set, then the get
            methods check that only white space follows valid data and a
            FormatException is thrown if that is not the case.  If
            fillFields is not set and valid data is found, then the
            methods return having read as much as possible.  E.g., for
            the sequence "T123.258E13", a getBoolean, getInteger and
            getFloat call would return true, 123, and 2.58e12 when
            called in succession.
            </p>
            </p>
            </summary>
        </member>
        <member name="P:nom.tam.util.ByteParser.Buffer">
            <summary>Get the buffer being used by the parser</summary>
            <summary>Set the buffer for the parser</summary>
        </member>
        <member name="P:nom.tam.util.ByteParser.Offset">
            <summary>Get the current offset.Set the offset into the array.</summary>
            <returns>The current offset within the buffer.</returns>
        </member>
        <member name="P:nom.tam.util.ByteParser.FillFields">
            <summary>Do we require a field to completely fill up the specified
            length (with optional leading and trailing white space.
            </summary>
        </member>
        <member name="P:nom.tam.util.ByteParser.NumberLength">
            <summary>Get the number of characters used to parse the previous
            number (or the length of the previous String returned).
            </summary>
        </member>
        <member name="P:nom.tam.util.ByteParser.Double">
            <summary>Read in the buffer until a double is read.  This will read
            the entire buffer if fillFields is set.
            </summary>
            <returns> The value found.
            
            </returns>
        </member>
        <member name="P:nom.tam.util.ByteParser.Float">
            <summary>Get a floating point value from the buffer.  (see getDouble(int())
            </summary>
        </member>
        <member name="P:nom.tam.util.ByteParser.Int">
            <summary>Look for an integer at the beginning of the buffer 
            </summary>
        </member>
        <member name="P:nom.tam.util.ByteParser.Boolean">
            <summary>Get a boolean value from the beginning of the buffer 
            </summary>
        </member>
        <member name="F:nom.tam.util.ByteParser.input">
            <summary>Array being parsed</summary>
        </member>
        <member name="F:nom.tam.util.ByteParser.offset">
            <summary>Current offset into input.</summary>
        </member>
        <member name="F:nom.tam.util.ByteParser.numberLength">
            <summary>Length of last parsed value</summary>
        </member>
        <member name="F:nom.tam.util.ByteParser.foundSign">
            <summary>Did we find a sign last time we checked?</summary>
        </member>
        <member name="F:nom.tam.util.ByteParser.fillFields">
            <summary>Do we fill up fields?</summary>
        </member>
        <member name="M:nom.tam.util.ByteParser.#ctor(System.Byte[])">
            <summary>Construct a parser.</summary>
            <param name="input">byte array to be parsed.
            Note that the array can be re-used by
            refilling its contents and resetting the offset.</param>
        </member>
        <member name="M:nom.tam.util.ByteParser.GetDouble(System.Int32)">
            <summary>Look for a double in the buffer.  Leading spaces are ignored.</summary>
            <param name="length">The maximum number of characters used to parse this number.
            If fillFields is specified then exactly only whitespace may follow
             a valid double value.</param>
        </member>
        <member name="M:nom.tam.util.ByteParser.GetFloat(System.Int32)">
            <summary>Get a floating point value in a region of the buffer</summary>
        </member>
        <member name="M:nom.tam.util.ByteParser.GetInt(System.Int32)">
            <summary>Convert a region of the buffer to an integer</summary>
        </member>
        <member name="M:nom.tam.util.ByteParser.GetLong(System.Int32)">
            <summary>Look for a long in a specified region of the buffer</summary>
        </member>
        <member name="M:nom.tam.util.ByteParser.GetString(System.Int32)">
            <summary>Get a string</summary>
            <param name="length">The length of the string.</param>
        </member>
        <member name="M:nom.tam.util.ByteParser.GetBoolean(System.Int32)">
            <summary>Get a boolean value from a specified region of the buffer</summary>
        </member>
        <member name="M:nom.tam.util.ByteParser.Skip(System.Int32)">
            <summary>Skip bytes in the buffer 
            </summary>
        </member>
        <member name="M:nom.tam.util.ByteParser.GetBareInteger(System.Int32)">
            <summary>Get the integer value starting at the current position.
            This routine returns a double rather than an int/long
            to enable it to read very long integers (with reduced
            precision) such as 111111111111111111111111111111111111111111.
            Note that this routine does set numberLength.</summary>
            <param name="length">The maximum number of characters to use.</param>
        </member>
        <member name="M:nom.tam.util.ByteParser.SkipWhite(System.Int32)">
            <summary>Skip white space.  This routine skips with space in
            the input and returns the number of character skipped.
            White space is defined as ' ', '\t', '\n' or '\r'
            </summary>
            <param name="length">The maximum number of characters to skip.
            
            </param>
        </member>
        <member name="M:nom.tam.util.ByteParser.CheckSign">
            <summary>Find the sign for a number .
            This routine looks for a sign (+/-) at the current location
            and return +1/-1 if one is found, or +1 if not.
            The foundSign boolean is set if a sign is found and offset is
            incremented.
            </summary>
        </member>
        <member name="M:nom.tam.util.ByteParser.IsWhite(System.Int32)">
            <summary>Is a region blank?</summary>
            <param name="length">The length of the region to be tested</param>
        </member>
        <member name="T:nom.tam.util.ByteRenderer">
            <summary>
            summary description for ByteRenderers.
            </summary>
        </member>
        <member name="M:nom.tam.util.ByteRenderer.StringArrayByteRendererHeap.Render(System.Object,System.Byte[]@,System.Int32)">
            <summary>
            Writes the contents of o[0] (o must be of type String[]) to the heap tempfile.
            Writes the heap offset and length of o[0] to outputBuf
            (which ends up in the binary table)
            </summary>
            <param name="o"></param>
            <param name="outputBuf"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="T:nom.tam.util.ColumnTable">
            <summary>A data table is conventionally considered to consist of rows and
            columns, where the structure within each column is constant, but
            different columns may have different structures.  I.e., structurally
            columns may differ but rows are identical.
            Typically tabular data is usually stored in row order which can
            make it extremely difficult to access efficiently using Java.
            This class provides efficient
            access to data which is stored in row order and allows users to
            get and set the elements of the table.
            The table can consist only of arrays of primitive types.
            Data stored in column order can
            be efficiently read and written using the
            BufferedDataXputStream classes.
            *
            The table is represented entirely as a set of one-dimensional primitive
            arrays.  For a given column, a row consists of some number of
            contiguous elements of the array.  Each column is required to have
            the same number of rows.
            </summary>
        </member>
        <member name="P:nom.tam.util.ColumnTable.NRows">
            <summary>Get the number of rows in the table.</summary>
        </member>
        <member name="P:nom.tam.util.ColumnTable.NCols">
            <summary>Get the number of columns in the table.</summary>
        </member>
        <member name="P:nom.tam.util.ColumnTable.Bases">
            <summary>Get the base classes of the columns.</summary>
            <returns>An array of Class objects, one for each column.</returns>
        </member>
        <member name="P:nom.tam.util.ColumnTable.Columns">
            <summary>Get the actual data arrays</summary>
        </member>
        <member name="F:nom.tam.util.ColumnTable.arrays">
            <summary>The columns to be read/written</summary>
        </member>
        <member name="F:nom.tam.util.ColumnTable.sizes">
            <summary>The number of elements in a row for each column</summary>
        </member>
        <member name="F:nom.tam.util.ColumnTable.nrow">
            <summary>The number of rows</summary>
        </member>
        <member name="F:nom.tam.util.ColumnTable.chunk">
            <summary>The number or rows to read/write in one I/O.</summary>
        </member>
        <member name="F:nom.tam.util.ColumnTable.rowSize">
            <summary>The size of a row in bytes</summary>
        </member>
        <member name="F:nom.tam.util.ColumnTable.bases">
            <summary>The base type of each row (using the second character
            of the [x class names of the arrays.</summary>
        </member>
        <member name="M:nom.tam.util.ColumnTable.#ctor(System.Object[],System.Int32[])">
            <summary>Create the object after checking consistency.</summary>
            <param name="arrays"> An array of one-d primitive arrays representing columns.</param>
            <param name="sizes">  The number of elements in each row
            for the corresponding column</param>
        </member>
        <member name="M:nom.tam.util.ColumnTable.Setup(System.Object[],System.Int32[])">
            <summary>Actually perform the initialization.</summary>
        </member>
        <member name="M:nom.tam.util.ColumnTable.GetColumn(System.Int32)">
            <summary>Get a particular column.</summary>
            <param name="col">The column desired.</param>
            <returns> an object containing the column data desired.
            This will be an instance of a 1-d primitive array.</returns>
        </member>
        <member name="M:nom.tam.util.ColumnTable.SetColumn(System.Int32,System.Object)">
            <summary>Set the values in a particular column.
            The new values must match the old in length but not necessarily in type.
            </summary>
            <param name="col">The column to modify.</param>
            <param name="newColumn">The new column data.  This should be a primitive array.</param>
            <exception cref="!:"> TableException Thrown when the new data is not commenserable with
            informaiton in the table.</exception>
        </member>
        <member name="M:nom.tam.util.ColumnTable.AddColumn(System.Array,System.Int32)">
            <summary>Add a column.</summary>
        </member>
        <member name="M:nom.tam.util.ColumnTable.AddRow(System.Object[])">
            <summary>Add a row to the table.  This method is very inefficient
            for adding multiple rows and should be avoided if possible.
            </summary>
            <exception cref="T:nom.tam.util.TableException"> TableException Thrown when the new data
            is not of the same type as the data it replaces.</exception>
        </member>
        <member name="M:nom.tam.util.ColumnTable.GetElement(System.Int32,System.Int32)">
            <summary>Get a element of the table.</summary>
            <param name="row">The row desired.</param>
            <param name="col">The column desired.</param>
            <returns> A primitive array containing the information.  Note
            that an array will be returned even if the element
            is a scalar.</returns>
        </member>
        <member name="M:nom.tam.util.ColumnTable.SetElement(System.Int32,System.Int32,System.Object)">
            <summary>Modify an element of the table.</summary>
            <param name="row">The row containing the element.</param>
            <param name="col">The column containing the element.</param>
            <param name="x">  The new datum.  This should be 1-d primitive array.</param>
            <exception cref="T:nom.tam.util.TableException"> TableException Thrown when the new data
            is not of the same type as the data it replaces.</exception>
        </member>
        <member name="M:nom.tam.util.ColumnTable.GetRow(System.Int32)">
            <summary>Get a row of data.</summary>
            <param name="The">row desired.</param>
            <returns> An array of objects each containing a primitive array.</returns>
        </member>
        <member name="M:nom.tam.util.ColumnTable.SetRow(System.Int32,System.Object)">
            <summary>Modify a row of data.</summary>
            <param name="row">The row to be modified.</param>
            <param name="x">  The data to be modified.  This should be an
            array of objects.  It is described as an Object
            here since other table implementations may
            use other methods to store the data (e.g.,</param>
            <exception cref="T:nom.tam.util.TableException"> TableException Thrown when the new data
            is not of the same type as the data it replaces.</exception>
            <seealso cref="!:">ColumnTable.getColumn.</seealso>
        </member>
        <member name="M:nom.tam.util.ColumnTable.CheckArrayConsistency(System.Object[],System.Int32[])">
            <summary>Check that the columns and sizes are consistent.
            Inconsistencies include:
            * arrays and sizes have different lengths.
            * an element of arrays is not a primitive array.
            * the size of an array is not divisible by the sizes entry.
            * the number of rows differs for the columns.
            </summary>
            <param name="arrays">The arrays defining the columns.</param>
            <param name="sizes">The number of elements in each row for the column.</param>
            <exception cref="T:nom.tam.util.TableException"> TableException Thrown when the new data
            is not of the same type as the data it replaces.</exception>
        </member>
        <member name="M:nom.tam.util.ColumnTable.GetNumberOfRows">
            <summary>Calculate the number of rows to read/write at a time.</summary>
        </member>
        <member name="M:nom.tam.util.ColumnTable.InitializePointers">
            <summary>Set the pointer arrays for the eight primitive types
            to point to the appropriate elements of arrays.</summary>
        </member>
        <member name="M:nom.tam.util.ColumnTable.AddPointer(System.Object)">
            <summary>
             Add a pointer in the pointer lists.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:nom.tam.util.ColumnTable.Read(nom.tam.util.ArrayDataIO)">
            <summary>Read a table.</summary>
            <param name="is">The input stream to read from.</param>
        </member>
        <member name="M:nom.tam.util.ColumnTable.Write(nom.tam.util.ArrayDataIO)">
            <summary>Write a table.</summary>
            <param name="os">the output stream to write to.</param>
        </member>
        <member name="M:nom.tam.util.ColumnTable.DeleteRow(System.Int32)">
            <summary>Delete a row from the table.</summary>
            <param name="row">The row (0-indexed) to be deleted.</param>
        </member>
        <member name="M:nom.tam.util.ColumnTable.DeleteRows(System.Int32,System.Int32)">
            Delete a contiguous set of rows from the table.
            <param name="row">The row (0-indexed) to be deleted.</param>
            <param name="length">The number of rows to be deleted.</param>
            <exception cref="T:nom.tam.util.TableException"> TableException Thrown when the new data
            is not of the same type as the data it replaces.</exception>
        </member>
        <member name="M:nom.tam.util.ColumnTable.DeleteColumns(System.Int32,System.Int32)">
            Delete a contiguous set of columns from the table.
            <param name="start">The column (0-indexed) to be deleted.</param>
            <param name="len">The number of rows to be deleted.</param>
            <exception cref="T:nom.tam.util.TableException"> TableException Thrown when the new data
            is not of the same type as the data it replaces.</exception>
        </member>
        <member name="T:nom.tam.util.ConfigStream">
            <summary>
            summary description for ConfigStream.
            </summary>
        </member>
        <member name="T:nom.tam.util.Cursor">
            <summary>This interface extends the IEnumerator interface
            to allow insertion of data and move to previous entries
            in a collection.
            </summary>
        </member>
        <member name="P:nom.tam.util.Cursor.Key">
            <summary>Point the list at a particular element.
            Point to the end of the list if the key is not found.
            </summary>
        </member>
        <member name="M:nom.tam.util.Cursor.MovePrevious">
            <summary>Move to the previous element</summary>
        </member>
        <member name="M:nom.tam.util.Cursor.Add(System.Object)">
            <summary>Add an unkeyed element to the collection.
            The new element is placed such that it will be called
            by a prev() call, but not a next() call.
            </summary>
        </member>
        <member name="M:nom.tam.util.Cursor.Insert(System.Object,System.Object)">
            <summary>Add a keyed element to the collection.
            The new element is placed such that a next() call. 
            The cursor position is not incremented in this method.</summary>
        </member>
        <member name="M:nom.tam.util.Cursor.Add(System.Object,System.Object)">
            <summary>Add a keyed element to the collection.
            The new element is placed such that it will be called
            by a prev() call, but not a next() call.
            The cursor position is changed after adding a value.
            </summary>
        </member>
        <member name="M:nom.tam.util.Cursor.Remove">
            <summary>Remove the current object from the collection</summary>
        </member>
        <member name="T:nom.tam.util.DataTable">
            <summary>This interface defines the properties that
            a generic table should have.
            </summary>
        </member>
        <member name="T:nom.tam.util.DefaultValueHashtable">
            <summary>
            summary description for DefaultValueHashtable.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:nom.tam.util.HashedList" -->
        <member name="F:nom.tam.util.HashedList.keyed">
            <summary>The HashTable of keyed indices.</summary>
        </member>
        <member name="F:nom.tam.util.HashedList.ordered">
            <summary>An ordered List of the keys.</summary>
        </member>
        <member name="F:nom.tam.util.HashedList.unkeyedIndex">
            <summary>This is used to generate unique keys for
            elements entered without an key.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.#ctor">
            <summary>
            Constructor creating new hast table and arraylist structures
            </summary>
        </member>
        <member name="M:nom.tam.util.HashedList.InitBlock">
            <summary>
            Initializes a new HashTable and Arraylist
            </summary>
        </member>
        <member name="P:nom.tam.util.HashedList.Item(System.Object)">
            <summary>Returns Value corresponding to \"Key\".</summary>
            <param name="key">Key pointing Value</param>
        </member>
        <member name="P:nom.tam.util.HashedList.Item(System.Int32)">
            <summary>Key at specified \"index\".</summary>
            <param name="index">Index of Key</param>
        </member>
        <member name="P:nom.tam.util.HashedList.Empty">
            <summary>Is the HashedList empty?</summary>
        </member>
        <member name="P:nom.tam.util.HashedList.HashedListCursor.Key">
            <summary>
            Point the Cursor to a particular keyed entry.  This
            method is not in the IEnumerator interface.
            </summary>
        </member>
        <member name="M:nom.tam.util.HashedList.HashedListCursor.MoveNext">
            <summary>Is there another element?</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.HashedListCursor.Reset">
            <summary>
            Resetting the cursor's current position to -1
            </summary>
        </member>
        <member name="M:nom.tam.util.HashedList.HashedListCursor.MovePrevious">
            <summary>Move to the previous entry.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.HashedListCursor.Remove">
            <summary>Remove the current entry. Note that remove can
            be called only after a call to next, and only once per such
            call.  Remove cannot be called after a call to prev.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.HashedListCursor.Add(System.Object)">
            <summary>Add an entry at the current location. The new entry goes before
            the entry that would be returned in the next 'next' call, and
            that call will not be affected by the insertion. 
            Note: this method is not in the IEnumerator interface.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.HashedListCursor.Insert(System.Object,System.Object)">
            <summary>
            Insert an entry ar the current location.Cursor positionis not incremented.So new entry is retived using next call
            </summary>
            <param name="key"></param>
            <param name="val"></param>
        </member>
        <member name="M:nom.tam.util.HashedList.HashedListCursor.Add(System.Object,System.Object)">
            <summary>
            Add a keyed entry at the current location. The new entry is inserted
            before the entry that would be returned in the next invocation of
            'next'.  The return value for that call is unaffected.
            Note: this method is not in the IEnumerator interface.
            </summary>
        </member>
        <member name="F:nom.tam.util.HashedList.HashedListCursor.current">
            <summary>The element that will be returned by next.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.Add(System.Object)">
            <summary>Add an element to the end of the list.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.Add(System.Int32,System.Object,System.Object)">
            <summary>Add an element to the list.</summary>
            <param name="pos">The element after which the current element 
            be placed.  If pos is null put the element at the end of the list.</param>
            <param name="key">The hash key for the new object.  This may be null
            for an unkeyed entry.</param>
            <param name="reference">The actual object being stored.</param>
        </member>
        <member name="M:nom.tam.util.HashedList.RemoveElement(System.Int32)">
            <summary>Remove an element from the list.
            This method is also called by the HashedListCursor.
            </summary>
            <param name="index">The element to be removed.</param>
        </member>
        <member name="M:nom.tam.util.HashedList.RemoveKey(System.Object)">
            <summary>
            Removes the key from hash and list
            </summary>
            <param name="key"></param>
            <returns>returns false if key not found in has or true on success</returns>
        </member>
        <member name="M:nom.tam.util.HashedList.GetCursor">
            <summary>Return a Cursor over the entire list.
            The Cursor may be used to delete
            entries as well as to retrieve existing
            entries.  A knowledgeable user can
            cast this to a HashedListCursor and
            use it to add as well as delete entries.
            NOTE: Cursor is initialized with -1 in case the start index is not specified.
            </summary>
        </member>
        <member name="M:nom.tam.util.HashedList.GetCursor(System.Object)">
            <summary>
            Returns a cursor pointing to key "key"
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:nom.tam.util.HashedList.GetCursor(System.Int32)">
            <summary>Return a Cursor starting with the n'th entry.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.ReplaceKey(System.Object,System.Object)">
            <summary>Replace the key of a given element.</summary>
            <param name="oldKey"> The previous key.  This key must
            be present in the hash.</param>
            <param name="newKey"> The new key.  This key
            must not be present in the hash.</param>
            <returns>if the replacement was successful.</returns>
        </member>
        <member name="M:nom.tam.util.HashedList.ContainsValue(System.Object)">
            <summary>
            Returns true if val present in hashtable,else false
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:nom.tam.util.HashedList.ContainsKey(System.Object)">
            <summary>Check if the key is included in the list.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.Clear">
            <summary>Clear the collection 
            </summary>
        </member>
        <member name="P:nom.tam.util.HashedList.Count">
            <summary>
            Gets the count of hashtable
            </summary>
        </member>
        <member name="M:nom.tam.util.HashedList.toArray">
            <summary>Convert to an array of objects</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.toArray(System.Object[])">
            <summary>Convert to an array of objects of a specified type.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.Sort(System.Collections.IComparer)">
            <summary>Sort the keys into some desired order.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.System#Collections#IDictionary#GetEnumerator">
            <summary>
            gets the current cursor
            </summary>
        </member>
        <member name="M:nom.tam.util.HashedList.Add(System.Object,System.Object)">
            <summary>Add a keyed element to the end of the list.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.AddAll(System.Collections.IDictionary)">
            <summary>Add another collection to this one list.
            All entries are added as unkeyed entries to the end of the list.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.Remove(System.Object)">
            <summary>Remove a keyed object from the list.  Unkeyed
            objects can be removed from the list using a
            HashedListCursor.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.RemoveValue(System.Object)">
            <summary>
            Removes the value from the list
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:nom.tam.util.HashedList.RemoveUnkeyedObject(System.Object)">
            <summary>
            Removes Unkeyed value that matches 'val'.
            NOTE: if the value that is passed to be removed has to keys,
            one which was inserted with a key, and another without it, then
            it may be possible that the keyed value is removed if it is first in the order.
            </summary>
        </member>
        <member name="M:nom.tam.util.HashedList.RemoveAll(System.Collections.IDictionary)">
            <summary>Remove all the elements that are found in another collection.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.RetainAll(System.Collections.IDictionary)">
            <summary>Retain only elements contained in another collection.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.Contains(System.Object)">
            <summary>Check if the key is included in the list.</summary>
        </member>
        <member name="M:nom.tam.util.HashedList.ContainsAll(System.Collections.IDictionary)">
            <summary>Check if the collection is included in the list.</summary>
        </member>
        <member name="P:nom.tam.util.HashedList.Values">
            <summary>
            gets the values in hashtable
            </summary>
        </member>
        <member name="P:nom.tam.util.HashedList.Keys">
            <summary>
            Gets the keys in hashtable
            </summary>
        </member>
        <member name="T:nom.tam.util.HeapStream">
            <summary>
            summary description for HeapStream.
            </summary>
        </member>
        <member name="T:nom.tam.util.PrimitiveInfo">
            <Remarks>This interface collects some information about C# primitives.</Remarks>
        </member>
        <member name="F:nom.tam.util.PrimitiveInfo.sizes">
            <summary>Sizes.</summary>
        </member>
        <member name="T:nom.tam.util.RandomAccess">
            <Remarks>These packages define the methods which indicate that
            an i/o stream may be accessed in arbitrary order.
            The method signatures are taken from RandomAccessFile
            though that class does not implement this interface.
            </Remarks>
        </member>
        <member name="T:nom.tam.util.RowSource">
            <Remarks>
            summary description for RowSource.
            </Remarks>
        </member>
        <member name="T:nom.tam.util.StringToByteStream">
            <summary>
              Converts Strings to byte arrays and writes them to the underlying stream.
              Characters are written as 8-bit ASCII, not 16-bit unicode!!!
            </summary>
        </member>
        <member name="M:nom.tam.util.SupportClass.Identity(System.Int64)">
            <summary>This method is used as a dummy method to simulate VJ++ behavior</summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:nom.tam.util.SupportClass.Identity(System.UInt64)">
            <summary>This method is used as a dummy method to simulate VJ++ behavior</summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:nom.tam.util.SupportClass.Identity(System.Single)">
            <summary>This method is used as a dummy method to simulate VJ++ behavior</summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:nom.tam.util.SupportClass.Identity(System.Double)">
            <summary>This method is used as a dummy method to simulate VJ++ behavior</summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:nom.tam.util.SupportClass.ToByteArray(System.String)">
            <summary>Converts a string to an array of bytes</summary>
            <param name="sourceString">The string to be converted</param>
            <returns>The new array of bytes</returns>
        </member>
        <member name="M:nom.tam.util.SupportClass.ToCharArray(System.Byte[])">
            <summary>
            Converts an array of bytes to an array of chars
            </summary>
            <param name="byteArray">The array of bytes to convert</param>
            <returns>The new array of chars</returns>
        </member>
        <member name="T:nom.tam.util.TableException">
            <summary>
            Table Exception handling class
            </summary>
        </member>
        <member name="T:nom.tam.util.Troolean">
            <summary>
              To replace C# non-nullable bool struct.
            </summary>
        </member>
        <member name="M:nom.tam.util.TruncationException.#ctor">
            <summary>
            Truncation Exception handling class
            </summary>
        </member>
    </members>
</doc>
